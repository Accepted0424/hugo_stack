<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Git on Az's Blog</title><link>https://lhy0424.top/tags/git/</link><description>Recent content in Git on Az's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 13 Mar 2025 22:58:00 +0000</lastBuildDate><atom:link href="https://lhy0424.top/tags/git/index.xml" rel="self" type="application/rss+xml"/><item><title>BUAA-OS-lab0 实验报告</title><link>https://lhy0424.top/p/os-lab0/</link><pubDate>Thu, 13 Mar 2025 22:58:00 +0000</pubDate><guid>https://lhy0424.top/p/os-lab0/</guid><description>&lt;img src="https://lhy0424.top/p/os-lab0/cover.jpg" alt="Featured image of post BUAA-OS-lab0 实验报告" />&lt;h1 id="os-lab0-实验报告">OS-lab0 实验报告
&lt;/h1>&lt;h2 id="思考题">思考题
&lt;/h2>&lt;h3 id="thinking-01">Thinking 0.1
&lt;/h3>&lt;blockquote>
&lt;ul>
&lt;li>在前述已初始化的 ~/learnGit 目录下，创建一个名为 README.txt 的文件。执 行命令 git status &amp;gt; Untracked.txt（其中的 &amp;gt; 为输出重定向，我们将在 0.6.3 中 详细介绍）。&lt;/li>
&lt;li>在 README.txt 文件中添加任意文件内容，然后使用 add 命令，再执行命令 git status &amp;gt; Stage.txt。&lt;/li>
&lt;li>提交 README.txt，并在提交说明里写入自己的学号。&lt;/li>
&lt;li>执行命令 cat Untracked.txt 和 cat Stage.txt，对比两次运行的结果，体会 README.txt 两次所处位置的不同。&lt;/li>
&lt;li>修改 README.txt 文件，再执行命令 git status &amp;gt; Modified.txt。&lt;/li>
&lt;li>执行命令 cat Modified.txt，观察其结果和第一次执行 add 命令之前的 status 是 否一样，并思考原因。&lt;/li>
&lt;/ul>&lt;/blockquote>
&lt;p>不一样，新建一个文件但不git add，README.txt处于未跟踪状态；git add之后会跟踪README.txt文件，此时文件处于已暂存状态；提交后修改README.txt文件，此时文件处于已修改状态，但是还未添加到暂存区。&lt;/p>
&lt;h3 id="thinking-02">Thinking 0.2
&lt;/h3>&lt;blockquote>
&lt;p>仔细看看0.10，思考一下箭头中的 add the file 、stage the file 和 commit 分别对应的是 Git 里的哪些命令呢？&lt;/p>
&lt;p>&lt;img src="https://lhy0424.top/p/os-lab0/git.png"
width="1266"
height="682"
srcset="https://lhy0424.top/p/os-lab0/git_hu_fa9b83922f61d433.png 480w, https://lhy0424.top/p/os-lab0/git_hu_583c1993dd3dd65d.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="185"
data-flex-basis="445px"
>&lt;/p>&lt;/blockquote>
&lt;p>add the file对应git add，stage the file对应git add，commit对应git commit&lt;/p>
&lt;h3 id="thinking-03">Thinking 0.3
&lt;/h3>&lt;blockquote>
&lt;p>思考下列问题：&lt;/p>
&lt;ol>
&lt;li>代码文件 print.c 被错误删除时，应当使用什么命令将其恢复？&lt;/li>
&lt;li>代码文件 print.c 被错误删除后，执行了 git rm print.c 命令，此时应当 使用什么命令将其恢复？&lt;/li>
&lt;li>无关文件 hello.txt 已经被添加到暂存区时，如何在不删除此文件的前提下 将其移出暂存区？&lt;/li>
&lt;/ol>&lt;/blockquote>
&lt;ol>
&lt;li>如果文件在暂存后被删除，可以使用git checkout &amp;ndash; print.c恢复。如果文件在删除前执行了git commit，在删除后执行了git add指令，可以使用git reset HEAD恢复到上一次commit时的状态，之后再使用git checkout &amp;ndash; print.c恢复文件。&lt;/li>
&lt;li>先使用git restore &amp;ndash;staged print.c取消暂存，再使用git restore print.c放弃工作区的修改。&lt;/li>
&lt;li>git rm &amp;ndash;cached hello.txt&lt;/li>
&lt;/ol>
&lt;h3 id="thinking-04">Thinking 0.4
&lt;/h3>&lt;blockquote>
&lt;p>思考下列有关 Git 的问题：&lt;/p>
&lt;ul>
&lt;li>找到在 /home/22xxxxxx/learnGit 下刚刚创建的 README.txt 文件，若不存 在则新建该文件。&lt;/li>
&lt;li>在文件里加入 Testing 1，git add，git commit，提交说明记为 1。&lt;/li>
&lt;li>模仿上述做法，把 1 分别改为 2 和 3，再提交两次。&lt;/li>
&lt;li>使用 git log 命令查看提交日志，看是否已经有三次提交，记下提交说明为 3 的哈希值a。&lt;/li>
&lt;li>进行版本回退。执行命令 git reset &amp;ndash;hard HEAD^ 后，再执行 git log，观察其变化。&lt;/li>
&lt;li>找到提交说明为 1 的哈希值，执行命令 git reset &amp;ndash;hard &amp;lt;hash&amp;gt;后，再执 行 git log，观察其变化。&lt;/li>
&lt;li>现在已经回到了旧版本，为了再次回到新版本，执行 git reset &amp;ndash;hard &amp;lt;hash&amp;gt;，再执行 git log，观察其变化。&lt;/li>
&lt;/ul>&lt;/blockquote>
&lt;ul>
&lt;li>有三次提交&lt;/li>
&lt;li>HEAD指向说明为2的提交，并且不显示说明为3的提交&lt;/li>
&lt;li>HEAD指向说明为1的提交，并且不显示说明为2, 3的提交&lt;/li>
&lt;li>HEAD指向说明为3的提交&lt;/li>
&lt;/ul>
&lt;h3 id="thinking-05">Thinking 0.5
&lt;/h3>&lt;blockquote>
&lt;p>执行如下命令, 并查看结果&lt;/p>
&lt;ul>
&lt;li>echo first&lt;/li>
&lt;li>echo second &amp;gt; output.txt&lt;/li>
&lt;li>echo third &amp;gt; output.txt&lt;/li>
&lt;li>echo forth &amp;raquo; output.txt&lt;/li>
&lt;/ul>&lt;/blockquote>
&lt;ul>
&lt;li>在终端显示&amp;quot;first&amp;quot;&lt;/li>
&lt;li>创建了一个output.txt文件，内容为&amp;quot;second&amp;quot;&lt;/li>
&lt;li>output.txt内容变为&amp;quot;third&amp;quot;&lt;/li>
&lt;li>output.txt追加内容&amp;quot;forth&amp;quot;&lt;/li>
&lt;/ul>
&lt;h3 id="thinking-06">Thinking 0.6
&lt;/h3>&lt;blockquote>
&lt;p>使用你知道的方法（包括重定向）创建下图内容的文件（文件命名为 test）， 将创建该文件的命令序列保存在 command 文件中，并将 test 文件作为批处理文件运行，将 运行结果输出至 result 文件中。给出 command 文件和 result 文件的内容，并对最后的结果进行解释说明（可以从 test 文件的内容入手）. 具体实现的过程中思考下列问题: echo echo Shell Start 与 echo `echo Shell Start` 效果是否有区别; echo echo $c&amp;gt;file1 与 echo `echo $c&amp;gt;file1` &amp;lsquo;效果是否有区别.&lt;/p>&lt;/blockquote>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;echo Shell Start...&amp;#39;&lt;/span> &amp;gt; &lt;span class="nb">test&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;echo set a = 1&amp;#39;&lt;/span> &amp;gt;&amp;gt; &lt;span class="nb">test&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;a=1&amp;#39;&lt;/span> &amp;gt;&amp;gt; &lt;span class="nb">test&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;echo set b = 2&amp;#39;&lt;/span> &amp;gt;&amp;gt; &lt;span class="nb">test&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;b=2&amp;#39;&lt;/span> &amp;gt;&amp;gt; &lt;span class="nb">test&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;echo set c = a+b&amp;#39;&lt;/span> &amp;gt;&amp;gt; &lt;span class="nb">test&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;c=$[$a+$b]&amp;#39;&lt;/span> &amp;gt;&amp;gt; &lt;span class="nb">test&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;echo c = $c&amp;#39;&lt;/span> &amp;gt;&amp;gt; &lt;span class="nb">test&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;echo save c to ./file1&amp;#39;&lt;/span> &amp;gt;&amp;gt; &lt;span class="nb">test&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;echo $c&amp;gt;file1&amp;#39;&lt;/span> &amp;gt;&amp;gt; &lt;span class="nb">test&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;echo save b to ./file2&amp;#39;&lt;/span> &amp;gt;&amp;gt; &lt;span class="nb">test&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;echo $b&amp;gt;file2&amp;#39;&lt;/span> &amp;gt;&amp;gt; &lt;span class="nb">test&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;echo save a to ./file3&amp;#39;&lt;/span> &amp;gt;&amp;gt; &lt;span class="nb">test&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;echo $a&amp;gt;file3&amp;#39;&lt;/span> &amp;gt;&amp;gt; &lt;span class="nb">test&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;echo save file file2 file3 to file4&amp;#39;&lt;/span> &amp;gt;&amp;gt; &lt;span class="nb">test&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;cat file1&amp;gt;file4&amp;#39;&lt;/span> &amp;gt;&amp;gt; &lt;span class="nb">test&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;cat file2&amp;gt;&amp;gt;file4&amp;#39;&lt;/span> &amp;gt;&amp;gt; &lt;span class="nb">test&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;cat file3&amp;gt;&amp;gt;file4&amp;#39;&lt;/span> &amp;gt;&amp;gt; &lt;span class="nb">test&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;echo save file4 to ./result&amp;#39;&lt;/span> &amp;gt;&amp;gt; &lt;span class="nb">test&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;cat file4&amp;gt;&amp;gt;result&amp;#39;&lt;/span> &amp;gt;&amp;gt; &lt;span class="nb">test&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="m">3&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>结果分析&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>test先将a和b分别赋值为1和2&lt;/li>
&lt;li>令c等于a+b&lt;/li>
&lt;li>将c，b，a的值分别写入file1、file2、file3，三个文件中的值分别为3, 2, 1&lt;/li>
&lt;li>cat将这三个文件的值&lt;strong>追加&lt;/strong>到file4，再把file4中的内容写入result。&lt;/li>
&lt;li>result中的值为3, 2, 1。&lt;/li>
&lt;/ul>
&lt;p>&lt;code>echo echo Shell Start&lt;/code> 与 &lt;code>echo ‘echo Shell Start’&lt;/code> 效果没有区别； &lt;code>echo echo $c&amp;gt;file1&lt;/code> 与 &lt;code>echo ‘echo $c&amp;gt;file1’&lt;/code> 效果有区别，前者会将&amp;quot;echo $c&amp;quot;重定向到file1，而后者则会在终端显示&amp;quot;echo $c&amp;gt;file&amp;quot;。&lt;/p>
&lt;h2 id="实验难点">实验难点
&lt;/h2>&lt;h3 id="git的使用">Git的使用
&lt;/h3>&lt;h4 id="工作区暂存区版本库head的理解">工作区、暂存区、版本库、HEAD的理解
&lt;/h4>&lt;ul>
&lt;li>
&lt;p>工作区（Working Directory），电脑上的一个目录即为工作区。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>版本库（Repository），使用&lt;code>git init&lt;/code>指令，目录下会生成一个.git目录，这个.git目录就是git的版本库（.git不属于工作区），git版本库里有暂存区和一个指向当前分支的HEAD指针。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>暂存区（stage/index），使用&lt;code>git add&lt;/code>可以把修改后的文件添加到暂存区，以便于一次性提交多个修改。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>HEAD，HEAD指向的是当前分支（master/main&amp;hellip;），也可以指向某一个commit（分离状态）。&lt;/p>
&lt;ul>
&lt;li>分离状态，有时候我们只是想在之前的某一次commit上做一些调试而不想提交到版本库，我们就可以&lt;code>git checkout &amp;lt;hash&amp;gt;&lt;/code>切换到某一个commit进入HEAD分离状态，在进行一些修改并提交后，如果此时再切换到原有分支则会丢弃之前做的所有实验性修改，如果想保留修改，则可使用&lt;code>git checkout -b &amp;lt;new branch name&amp;gt;&lt;/code>新建一个分支保存修改。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>You are in &amp;lsquo;detached HEAD&amp;rsquo; state. You can look around, make experimental&lt;/p>
&lt;p>changes and commit them, and you can discard any commits you make in this&lt;/p>
&lt;p>state without impacting any branches by switching back to a branch.&lt;/p>
&lt;p>If you want to create a new branch to retain commits you create, you may&lt;/p>
&lt;p>do so (now or later) by using -c with the switch command. Example:&lt;/p>
&lt;p>git switch -c &lt;new-branch-name>&lt;/p>
&lt;p>Or undo this operation with:&lt;/p>
&lt;p>git switch -&lt;/p>
&lt;p>Turn off this advice by setting config variable advice.detachedHead to false&lt;/p>&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;h4 id="版本回退">版本回退
&lt;/h4>&lt;ul>
&lt;li>git reset [&amp;ndash;hard] [&amp;ndash;soft] [&amp;ndash;mixed]，同时移动当前分支指针和HEAD指针，&lt;code>--hard&lt;/code>会回退到上个版本的已提交状态，而&lt;code>--soft&lt;/code>会回退到上个版本的未提交状态，&lt;code>--mixed&lt;/code>会回退到上个版本已添加但未提交的状态。&lt;/li>
&lt;li>git checkout &amp;lt;hash&amp;gt;，仅移动HEAD指针，不一定分支指针（HEAD分离状态）。&lt;/li>
&lt;li>git checkout &amp;ndash; &amp;lt;file&amp;gt;，将暂存区的指定文件取出，强制替换工作区的文件。&lt;/li>
&lt;li>git restore &amp;lt;file&amp;gt;，功能和git checkout相同。&lt;/li>
&lt;li>git rm &amp;ndash;cached &amp;lt;file&amp;gt;，从暂存区中删去不想跟踪的文件。&lt;/li>
&lt;/ul>
&lt;h4 id="冲突解决">冲突解决
&lt;/h4>&lt;p>当两个分支对同一行进行了修改，在合并时会出现冲突，git无法帮我们完成合并，需要手动解决冲突。&lt;/p>
&lt;p>&lt;img src="https://pic1.zhimg.com/80/v2-d3d10388e26645930816f8a52faa2b58_1440w.webp"
loading="lazy"
alt="v2-d3d10388e26645930816f8a52faa2b58_1440w"
>&lt;/p>
&lt;ul>
&lt;li>git merge，无破坏性，两个分支的提交均会被保存，但时间线会变复杂。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://picx.zhimg.com/80/v2-f4395af8dd25bd70b7a75a08d57151f7_1440w.webp"
loading="lazy"
alt="v2-f4395af8dd25bd70b7a75a08d57151f7_1440w"
>&lt;/p>
&lt;ul>
&lt;li>git rebase，重写原始分支的提交历史，将当前修改融合到原始分支中，原始分支的hash会变，时间线更干净但是损失了很多信息，可回溯性差。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://pic2.zhimg.com/80/v2-313d33b3c539fc4ab359590a32d26569_1440w.webp"
loading="lazy"
alt="v2-313d33b3c539fc4ab359590a32d26569_1440w"
>&lt;/p>
&lt;h3 id="makefile">Makefile
&lt;/h3>&lt;ul>
&lt;li>本质上target和dependencies都是文件，如果target已经存在，且创建时间晚于所有dependencies，则make不会执行命令。&lt;/li>
&lt;li>如果一个规则的命令没有创建target文件，我们希望每次执行&lt;code>make &amp;lt;target&amp;gt;&lt;/code>都会执行这个规则的命令，但是如果我们手动创建了一个target文件，则命令不会被执行，这是我们可以把这个target声明为伪目标，例如&lt;code>.PHONY: clean&lt;/code>&lt;/li>
&lt;/ul>
&lt;h3 id="shell脚本">Shell脚本
&lt;/h3>&lt;h4 id="转义">转义
&lt;/h4>&lt;ul>
&lt;li>单引号保留字符的字面含义，单引号内不能再使用单引号，即使使用了反斜线转义也不允许。&lt;/li>
&lt;li>双引号内美元符号&lt;code>$&lt;/code> ，反引号`` &lt;code>，反斜杠&lt;/code>`仍然有特殊含义&lt;/li>
&lt;/ul>
&lt;h4 id="括号">括号
&lt;/h4>&lt;ul>
&lt;li>[] 逻辑运算&lt;/li>
&lt;li>(()) 用于算术表达式，也可在其中进行变量赋值&lt;/li>
&lt;li>${} 取变量的值&lt;/li>
&lt;li>$[] 和 $(()) 数值计算并返回值&lt;/li>
&lt;li>$() 运行括号中的命令并将输出替换到原处&lt;/li>
&lt;/ul>
&lt;h3 id="sed-stream-editor">Sed (Stream editor)
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sed &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &lt;span class="s1">&amp;#39;命令&amp;#39;&lt;/span> 输入文本
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>sed命令本身是可以解释语法的，即传入一个字符串作为命令，sed可以解析这个字符串，而我们如果要在命令中使用变量直接输入‘$1,$p’是无法被正确解析的，因为在sed命令看来$1就是一个普通字符串，我们应该把$1交给shell去解析。很简单，只需要$1放在单引号外面即可。&lt;/p>
&lt;p>于是，关于sed如何和shell交互的问题可以得出一套结论：&lt;/p>
&lt;ol>
&lt;li>遇到需要被shell解析的都不加引号，或者加双引号；&lt;/li>
&lt;li>遇到shell和所执行命令共有的特殊字符时，要想被sed解析，必须加单引号，或者在双引号在加反斜线转义；&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">➜ learnSed cat tail.sh
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#!/bin/bash&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sed -n &lt;span class="nv">$1&lt;/span>&lt;span class="s1">&amp;#39;,$p&amp;#39;&lt;/span> &lt;span class="nv">$2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➜ learnSed bash tail.sh &lt;span class="m">4&lt;/span> &lt;span class="nb">test&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">line4
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">line5
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">line6
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="实验体会">实验体会
&lt;/h2>&lt;ul>
&lt;li>git的基本操作很简单，但是在实际多人合作中，版本回退、冲突处理等问题层出不穷，没有深入的理解很难提高效率。&lt;/li>
&lt;li>刚开始接触linux和CLI，只会一些基础命令，对shell脚本的理解不深，导致上机测试手忙脚乱，不能很快定位错误。&lt;/li>
&lt;li>指导书中的命令只是冰山一角，要熟练使用shell仍需要花大量的时间去自学。&lt;/li>
&lt;/ul>
&lt;h2 id="参考资料">参考资料
&lt;/h2>&lt;ul>
&lt;li>
&lt;p>在开发过程中使用 git rebase 还是 git merge，优缺点分别是什么？https://www.zhihu.com/question/36509119/answer/2423381574&lt;/p>
&lt;/li>
&lt;li>
&lt;p>廖雪峰的Makefile教程 &lt;a class="link" href="https://liaoxuefeng.com/books/makefile/introduction/index.html" target="_blank" rel="noopener"
>https://liaoxuefeng.com/books/makefile/introduction/index.html&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sed中的疑难杂症 &lt;a class="link" href="https://zhuanlan.zhihu.com/p/691207825" target="_blank" rel="noopener"
>https://zhuanlan.zhihu.com/p/691207825&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul></description></item></channel></rss>
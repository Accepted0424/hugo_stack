[{"content":"BUAA-OO-Unit2总结 三次迭代回顾 第五次作业\n本单元以某公司大楼的目的选层电梯系统为背景。\n目的选层电梯系统的运行流程：\n进入电梯前，乘客输入目标楼层； 系统根据设定的策略指定最合适的电梯来服务，将结果告知乘客； 乘客进入指定电梯后，无需再次按楼层按钮，电梯会自动将其送至目标楼层。 与普通的目的选层电梯系统有所区分的是，该公司为提高运行效率，充分考虑不同职位的员工所从事工作的时间急迫性，为不同类型的乘客请求赋予了优先级指数。优先级指数描述了乘客到达目的楼层的急迫程度。\n第六次作业\n本次作业的新增内容有：\n取消“乘客请求指定电梯”约束，需要自行设计电梯分配策略 新增“临时调度”请求；新增“RECEIVE”约束 修改乘客请求格式；修改“OUT”指令输出格式；修改测试数据约束；修改“实现提示”“提示与警示”部分 第七次作业\n本次作业的新增内容有：\n新增双轿厢电梯改造 修改\u0026quot;RECEIVE\u0026quot;约束；修改临时调度约束 性能要求\n抛开麻烦的公式，简单来说就是\n运行时间尽量短 尽量满足乘客请求的优先级 尽量减少系统的无效运行 生产者-消费者模型 程序在运行中任何时刻都有可能收到用户请求，我们不能收到一个请求就立刻将其分配给某个电梯去处理，因为电梯处理一个请求需要时间，如果在处理一个请求的过程中接收到了一个请求该怎么办呢？是放弃当前请求还是放弃新接受到的请求？显然都不合理。\n于是我们想到可以给每部电梯新建一个待处理的容器（队列、数组等等），里面放着分配给该部电梯的乘客请求。我们收到一个请求只需要把该请求放入对应电梯的待处理容器里即可，而对于电梯来说，它的任务只有一个，那就是把这个容器里的请求全部处理完即可。于是我们很自然的实现了一个多线程中的经典设计模型**\u0026ldquo;生产者-消费者模型\u0026rdquo;**。\n在第一次作业中，由于每一个请求都有指定的电梯，所以我们可以直接把请求放在对应电梯的待处理容器里。而在后续两次迭代中，需要我们自己决定乘客请求分配给哪个电梯，并且已经分配的请求有可能被取消需要被再次分配，因此我们还需要一个分配线程（Dispatch Thread）。\n综上，在本次电梯单元，我们需要用到两个生产者-消费者模型\n输入线程作为生产者，分配线程作为消费者。输入线程负责从外部读取用户请求，这些请求被放入⼀个输入缓冲区（请求队列）中。分配线程持续从该缓冲区中取出请求，进行传递sche和update信号、选择电梯等操作，并将调度结果发送到另⼀个调度缓冲区（电梯的待分配队列）。\n分配线程作为生产者，六个电梯线程作为消费者。分配线程将这些任务传递给具体的电梯线程，后者执行具体的操作，如移动电梯、开关门、响应请求等。\n多线程中的同步块与锁 在学习了OS之后，我们发现 Java 中的synchronized 关键字实现的就是一种管程（Monitor）机制，更准确地说，它实现的是一种MESA风格的管程。相比于Hoare管程，MESA管程的特点是当一个线程被 notify() 或 notifyAll() 唤醒时，它只是被放入了就绪队列，还要等待重新竞争锁，我们在设计时需要考虑这个问题。\nsynchronized是Java中的关键字，告诉JVM要对这个语句块进行线程互斥控制，其后的括号内需要一个对象用作锁，获取到锁才会执行代码块内的代码，执行结束后会释放锁。\n1 2 3 synchronized(object) { // 获取锁 ... } // 释放锁 为什么在Object.java中找不到和锁相关的代码？\n在 Java 里，每个对象都自动带有一个对象监视器（Monitor），这个机制由 JVM 层面（C++ 代码）实现，而不是在 Object.java 源码中。\nJava 的 synchronized 依赖于 对象头（Object Header） 中的 Mark Word 来存储锁状态。\n每个 Java 对象在 JVM 内存中存储结构如下：\n对象头 (Header) 实例数据 对齐填充 Mark Word（存储锁状态） + Class Pointer 成员变量 对齐数据 其中：\nMark Word 记录了对象的锁状态、线程 ID、GC 信息等。 当 synchronized 代码块运行时，JVM 会修改 Mark Word，进行加锁和解锁操作。 synchronized的使用方法有以下三种：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 关键字在实例方法上，锁为当前实例 public synchronized void instanceLock() { // code } // 关键字在静态方法上，锁为当前Class对象 public static ssynchronized void classLock() { // code } // 关键字在代码块上，锁为括号里面的对象 public void blockLock() { Object o = new Object(); synchronized (o) { // code } } 在三次作业中，我的所有同步设计都是通过synchronized关键字实现的，其实为了更好的性能应该使用读写锁分开处理读操作和写操作，但是由于时间原因就没有去重构。\n什么时候需要加锁是一个很关键的问题，笔者认为如果一个对象或数据可能同时被多个线程修改，或者多个线程同时读写该对象的状态，就应该加锁，或者使用线程安全的数据结构或机制。在三次作业中，RequestQueue（也就是电梯的待处理队列）就是需要重点关注的对象，因为分配线程和电梯线程都会对其进行访问。我们对其中可能造成数据冲突的方法都加上synchronized关键字，确保这些方法之间的互斥，这样我们就可以称RequestQueue类是线程安全的，这样我们在使用该类的方法时就无需考虑同步问题。\n当然也需要注意不能无脑加锁，把所有方法都加上synchronized关键字固然能保证没有数据冲突，但这样会大幅降低并发效率，可能会在一些情况下超出课程组给出的一些时间限制。\n策略设计 电梯调度策略 在三次作业中，每部电梯最多容纳6个乘客，我们该怎么保证在所有乘客都能到达目的地的情况下电梯运行时间尽可能少，优先级高的乘客能尽快到达目的地，并且尽可能减少耗电量。\n最常规的电梯调度策略是Look算法。\nSCAN 算法（也称电梯算法）是一种磁盘调度算法，用于确定磁盘臂和磁头在处理读写请求时的运动。它让电梯在最底层和最顶层之间连续往返运行，在运行过程中响应处在于电梯运行方向相同的各楼层上的请求。\nLOOK算法是对SCAN算法的改进，也是一种硬盘调度算法。当LOOK算法发现电梯所移动的方向上不再有请求时立即改变运行方向，而扫描算法则需要移动到最底层或者最顶层时才改变运行方向。\n现实中大多数电梯都采用LOOK算法或优化后的LOOK算法，但我们发现这个算法并没有考虑乘客的优先级。假设当前电梯在F1下行，电梯里有一个优先级为1的乘客正在前往B4，而这是有一个优先级为100的乘客在F2发出请求想要前往F7，显然这时候我们应该优先让电梯服务优先级为100的乘客。\n于是笔者尝试自己改造LOOK算法。仔细分析后，我们发现电梯调度问题的关键其实就是何时反转方向。不过需要注意的是我们在设计算法时不能针对某种特殊情况去优化，这样容易过拟合（Overfitting），即特殊情况下性能优越，但是平均性能有所下降。\n以下是笔者的一次算法优化尝试：\n对于电梯内的乘客，我们应该优先送优先级足够大的乘客，确保优先级大的乘客能尽快到达目的地，而不会被优先级太小的乘客拖长到达时间。具体实现方法为如果电梯里非空，比较向上的优先级和向下的优先级来确定下一步的移动方向。 $$\rPriority\\_up = \\sum_{toFLoor \u003e curfloor} \\frac{priority}{toFloor - curFloor}(对于电梯内所以目标楼层大于当前楼层的乘客)\r$$$$\rPriority\\_up = \\sum_{toFLoor \u003c curfloor} \\frac{priority}{curFloor-toFloor}(对于电梯内所以目标楼层小于当前楼层的乘客)\r$$ 对于电梯外的请求，我们应该先接优先级大且行程（ $|toFloor - fromFloor|$ ）较大的乘客。具体实现方法为如果电梯内部没人且电梯的待处理队列非空，则遍历待处理队列，找出综合优先级最大的乘客，根据该乘客的楼层确定电梯运行方向。 $$\rPriority\\_complex = priority \\times |toFloor - fromFloor|\r$$ 电梯内部满员时，我们可以让优先级足够小的乘客中途下电梯，让优先级足够大的乘客上去。具体实现方法为每到一层，先让到达目的地的乘客下来，如果电梯满员且该层存在未处理请求，则依次比较该层的所有请求乘客，如果其优先级为电梯内优先级最小的乘客的5倍以上，则让电梯内优先级最小的乘客下来，让对应的外部请求乘客上电梯。 其实这是一次比较失败的算法优化，在一些极端情况性能确实优于LOOK算法，在中测时性能和LOOK相当，但在强测数据量较大时普遍不如LOOK算法。\n分配策略 在第六和第七次作业中，我们需要自己决定一个请求应该分配给哪部电梯。这就涉及到一个问题，分配给哪部电梯才能保证性能分尽可能高。\n如果其他5部电梯都正在sche或update，如果这时突然来了100个请求，这时100个请求全部分配给一个电梯会导致整体运行时间过长。我们应该给电梯接收乘客请求的数量设置一个最大值，在所有电梯都不接收请求时分配线程进入等待状态，某个电梯空闲时唤醒分配线程。 对于第七次作业，电梯的可达楼层范围发生了变化，我们在分配时的条件也应该发生变化。我们应该首选可达fromFloor和toFloor的电梯接收请求，减少换乘带来的时间和电量损失，次选可达fromFloor，确保电梯可以接到对应乘客。 调度器（Dispatch）设计 结束和等待条件 未分配队列为空，但输入还未结束，应该进入等待状态，避免轮询。 因为所有电梯暂时无法接收乘客请求而无法继续分配，但是未分配队列非空，应该进入等待，避免轮询。 输入结束且未分配队列，此时应该跳出循环结束dispatch线程。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public void run() { while (true) { // 输入未结束，还有可能获取请求 while (isEmpty() \u0026amp;\u0026amp; !isEnd()) { try { dispatchWait(); } catch (InterruptedException e) { throw new RuntimeException(e); } } // 所有电梯处于忙碌状态，但是还有未分配请求，等待空闲电梯 while (allElevatorsBusy \u0026amp;\u0026amp; !isEmpty()) { synchronized (busyLock) { try { busyLock.wait(); } catch (InterruptedException e) { throw new RuntimeException(e); } } } // 输入结束，且没有未分配队列，告知电梯的已分配队列不会再有来自dispatch的分配 if (isEnd() \u0026amp;\u0026amp; isEmpty()) { for (int i = 1; i \u0026lt;= 6; i++) { elevators[i].getRequestQueue().setEnd(); } // 等待所有子任务结束 for (Future\u0026lt;?\u0026gt; f : futures) { try { f.get(); } catch (Exception e) { throw new RuntimeException(e); } } // 关闭线程池 executor.shutdown(); break; } // 分配操作 try { dispatch(); } catch (InterruptedException e) { throw new RuntimeException(e); } } } 其实分配线程有点类似 Java 中的守护（Daemon）线程，其必须要等到其他所有线程都结束之后才能结束，其必须要在所有电梯线程都结束之后才能结束。\n接收乘客请求 提供统一的offer接口，通过传参区分不同行为。\n对于乘客请求，其所在楼层是会发生变化的，由于我们无法直接修改personRequest实例的fromFloor，我们可以通过一个map来记录每个乘客的当前楼层。\n请求有以下分类：\n乘客请求（PersonRequest） 首次请求，nowFloorMap记录的楼层即为请求的fromFloor，需要记入总请求数 被取消的请求，nowFloorMap记录的楼层为乘客当前的楼层（通过参数传入），无需记入总请求数 中途下电梯的乘客请求，nowFloorMap记录的楼层为乘客当前的楼层（通过参数传入），无需记入总请求数 调度请求（ScheRequest） 双轿厢改造请求（UpdateRequest） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public synchronized void offer(Request r, Boolean isRearrange, Boolean first, int nowFloor) { if (r instanceof PersonRequest) { PersonRequest pr = (PersonRequest) r; unDispatchQueue.offer(pr); if (first) { nowFloorMap.put(pr, intOf(pr.getFromFloor())); } if (isRearrange) { nowFloorMap.put(pr, nowFloor); } if (!isRearrange \u0026amp;\u0026amp; first) { personRequestReceive++; } } else if (r instanceof ScheRequest) { ScheRequest sr = (ScheRequest) r; unDispatchSche.offer(sr); } else if (r instanceof UpdateRequest) { UpdateRequest ur = (UpdateRequest) r; try { elevators[ur.getElevatorAId()].acceptUpdate(ur); elevators[ur.getElevatorBId()].acceptUpdate(ur); } catch (Exception e) { e.printStackTrace(); } unDispatchUpdate.add(ur); hasFreeElevator(); } notifyAll(); } 分配请求 对于调度请求和乘客请求，我们直接将请求放入电梯的未分配队列即可 对于双轿厢改造请求，我们通过线程池来实现异步操作（后续详细解释）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 private synchronized void dispatch() throws InterruptedException { while (!unDispatchSche.isEmpty()) { ScheRequest sr = unDispatchSche.peek(); elevators[sr.getElevatorId()].getRequestQueue().offer(unDispatchSche.poll(), 0); } while (!unDispatchUpdate.isEmpty()) { UpdateRequest ur = unDispatchUpdate.poll(); Future\u0026lt;?\u0026gt; future = executor.submit(() -\u0026gt; { try { elevators[ur.getElevatorAId()].wait2clearInside(); elevators[ur.getElevatorBId()].wait2clearInside(); } catch (InterruptedException e) { throw new RuntimeException(e); } TimableOutput.println(String.format(\u0026#34;UPDATE-BEGIN-%d-%d\u0026#34;, ur.getElevatorAId(), ur.getElevatorBId())); try { Thread.sleep(1000); } catch (InterruptedException e) { throw new RuntimeException(e); } TimableOutput.println(String.format(\u0026#34;UPDATE-END-%d-%d\u0026#34;, ur.getElevatorAId(), ur.getElevatorBId())); elevators[ur.getElevatorAId()].updateDone(); elevators[ur.getElevatorBId()].updateDone(); }); futures.add(future); } // 分配给最近的空闲电梯 if (!unDispatchQueue.isEmpty()) { PersonRequest pr = unDispatchQueue.peek(); // 获取被分配电梯的序号 ...... TimableOutput.println( String.format(\u0026#34;RECEIVE-%d-%d\u0026#34;, pr.getPersonId(), elevators[target].getId())); elevators[target].getRequestQueue().offer(unDispatchQueue.poll(), nowFloorMap.get(pr)); } notifyAll(); } 双轿厢改造 \u0026ldquo;将一部电梯移动另一部电梯的电梯井中\u0026quot;的操作并不需要体现在代码中，我们只需要改变两部电梯的可达楼层范围即可。\n输出同步 同步输出是双轿厢电梯改造中比较麻烦的一点，因为其要求是两部电梯分别改造，但是需要统一输出。\n具体有两种实现方式：\n利用信号量进行线程间通信，当两个电梯都完成对应操作后统⼀输出\n异步处理，让电梯在处理完之后sleep一段时间确保二者都完成了对应操作之后由分配线程输出。\n笔者采用的第二种方法：\n在电梯线程接收到update请求后，立即告知两部电梯，让其尽快停下来，并且不再接收请求，因为update请求优先级大于乘客请求，所以要让电梯从等待中唤醒（如果所有电梯都不能接收乘客请求了）。 分配时，因为处理过程中涉及到分配线程的sleep，为了避免sleep期间不能接收请求的问题，我们创建一个子线程处理，子线程sleep并不影响分配线程。 等待两部电梯线程处于静止状态并清空内部所有的乘客之后由分配器子线程统一输出BEGIN，接着子线程会sleep一秒，确保满足改造时间限制。 电梯线程在清理完内部乘客之后也应该sleep1秒（最好大于1秒），因为BEGIN-END之间电梯是不能移动的，要等到输出END之后再输出。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 // Dispatch.java private ExecutorService executor = Executors.newFixedThreadPool(5); public synchronized void offer(Request r, Boolean isRearrange, Boolean first, int nowFloor) { if (r instanceof PersonRequest) { ... } else if (r instanceof ScheRequest) { ... } else if (r instanceof UpdateRequest) { UpdateRequest ur = (UpdateRequest) r; try { elevators[ur.getElevatorAId()].acceptUpdate(ur); elevators[ur.getElevatorBId()].acceptUpdate(ur); } catch (Exception e) { e.printStackTrace(); } unDispatchUpdate.add(ur); hasFreeElevator(); } notifyAll(); } private synchronized void dispatch() throws InterruptedException { while (!unDispatchSche.isEmpty()) {...} while (!unDispatchUpdate.isEmpty()) { UpdateRequest ur = unDispatchUpdate.poll(); Future\u0026lt;?\u0026gt; future = executor.submit(() -\u0026gt; { try { elevators[ur.getElevatorAId()].wait2clearInside(); elevators[ur.getElevatorBId()].wait2clearInside(); } catch (InterruptedException e) { throw new RuntimeException(e); } TimableOutput.println(String.format(\u0026#34;UPDATE-BEGIN-%d-%d\u0026#34;, ur.getElevatorAId(), ur.getElevatorBId())); try { Thread.sleep(1000); } catch (InterruptedException e) { throw new RuntimeException(e); } TimableOutput.println(String.format(\u0026#34;UPDATE-END-%d-%d\u0026#34;, ur.getElevatorAId(), ur.getElevatorBId())); elevators[ur.getElevatorAId()].updateDone(); elevators[ur.getElevatorBId()].updateDone(); }); futures.add(future); } // 分配给最近的空闲电梯 if (!unDispatchQueue.isEmpty()) {...} notifyAll(); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // Elevator.java private void executeUpdate() throws InterruptedException { inUpdate = true; updateHasBegin = true; if (!insideQueue.isEmpty()) { TimableOutput.println(String.format(\u0026#34;OPEN-%s-%d\u0026#34;, formatFloor(curFloor), id)); Thread.sleep(minTimeOpen2Close); allPersonOut(); TimableOutput.println(String.format(\u0026#34;CLOSE-%s-%d\u0026#34;, formatFloor(curFloor), id)); } insideHasClear(); hasAcceptUpdate = false; Thread.sleep(1100); updateParam(); removeAllReceive(); inUpdate = false; } 换乘层限制 线程间通信确保在同一电梯井的电梯的不会同时出现在换乘层。\n需要注意的是，在电梯前往换乘层的过程中就应该判定换乘层已经被占用。 电梯不应在换乘层等待，到达换乘层完成对应操作后应尽快离开。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 Status status = update(); if (status == Status.WAIT \u0026amp;\u0026amp; curFloor == transferFloor \u0026amp;\u0026amp; afterUpdate) { status = canMove() ? Status.MOVE : canReverse() ? Status.REVERSE : Status.WAIT; } switch (status) { case UPDATE: ... break; case OPEN: ... break; case MOVE: if ((curFloor + 1 == 0 \u0026amp;\u0026amp; curFloor + 2 == transferFloor) || curFloor + 1 == transferFloor) { transferFloorIsOccupied = true; } modifyFloor(true, false, false, 0); Thread.sleep(timePerFloor); TimableOutput.println(String.format(\u0026#34;ARRIVE-%s-%d\u0026#34;, formatFloor(curFloor), id)); if (curFloor != transferFloor) { transferFloorIsOccupied = false; } break; case REVERSE: if ((curFloor - 1 == 0 \u0026amp;\u0026amp; curFloor - 2 == transferFloor) || curFloor - 1 == transferFloor) { transferFloorIsOccupied = true; } modifyFloor(false, true, false, 0); Thread.sleep(timePerFloor); TimableOutput.println(String.format(\u0026#34;ARRIVE-%s-%d\u0026#34;, formatFloor(curFloor), id)); if (curFloor != transferFloor) { transferFloorIsOccupied = false; } break; default: break; } 架构设计 整体架构比较简单，只有五个类\nMainClass主线程接收输入 Dispatch线程对不同的请求进行分类处理 RequestQueue类是电梯的待处理队列，每个电梯实例都有一个RequestQueue实例作为缓冲区 Elevator线程对请求进行处理 笔者在设计的过程中找不到理由再抽象出一个类（可能OOP的思想还没学透彻吧），所以大量的处理逻辑集中在Elevator类中，导致Elevator类的代码行数接近500行。\nHW5 无分配线程，输入线程直接分配给电梯的待处理队列，当时认为完全没有必要引入分配线程，没能考虑后续迭代问题\nHW6 新增分配线程，在分配线程和电梯线程中增加调度逻辑\nHW7 在分配线程和电梯线程中新增Update异步处理逻辑\n三次迭代中整体架构设计变化不大，所以这里只放最后一次的设计架构：\n时序图（sequence diagram）：\nDebug 输出顺序\n在多线程中print的顺序十分重要，因为当前线程的操作会影响到其他线程的运行，且题目中有着严格的输出循序要求。一些print需要在操作之后，一些需要在操作之前。\n楼层计数\n把楼层转化为int类型后，使用时不能直接用floor+1或floor-1，因为F1（+1）的下一层是B1（-1）而不是0。\ndebug方法 由于程序的输出需要通过官方程序，调试起来很麻烦，所以我大部分的debug都是通过添加输出来实现的。\n由于Java好像没有全局变量，只好在MainClass里声明一个public static final类型的变量来近似实现全局变量的效果。\n声明一个全局debug控制开关，用来控制是否显示调试信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 // MainClass.java public class MainClass { // debug info public static final boolean debug = false; public static final String RESET = \u0026#34;\\u001B[0m\u0026#34;; // 重置颜色 public static final String YELLOW = \u0026#34;\\u001B[33m\u0026#34;; // 黄色 public static final String BLUE = \u0026#34;\\u001B[34m\u0026#34;; // 蓝色 public static void main(String[] args) throws Exception { ... } } 1 2 3 4 5 // Elevator.java if (MainClass.debug) { TimableOutput.println(MainClass.BLUE + \u0026#34;WAITING...\u0026#34; + MainClass.RESET); } 评测机 由于官方的数据投喂包使用起来比较麻烦，所以自己写了一个自动化程序，能够实现快速的输入数据，再加上对输出的逻辑判断和性能指标计算即可构成一个简易评测机。\nhw7评测机源码：https://github.com/Accepted0424/quickHacker/blob/master/utils/quickInput_elevator3.py\n支持windows和mac平台。\n给定java项目文件夹，每次运行时会遍历文件夹下所有.java文件并自动引入官方依赖包生成.jar文件。操作简便，编辑完 java文件之后只需要直接Run Code即可，无需额外操作。\n可能比较完善的输出逻辑判断。\n支持输出三项性能指标。\n重要信息特殊颜色突出（SCHE、UPDATE、RECEIVE）。\n将输入输出保存至log，便于查找。\n心得体会 线程安全 在接触多线程编程之前，我一直以为“让多个线程一起工作”只是提升程序效率的一种手段。然而，真正深入学习之后才发现：线程安全是多线程编程中最难也最核心的问题之一。它不像语法错误那样容易察觉，往往潜伏在系统中，直到某一次并发冲突才暴露出严重的后果。线程安全并不是“写代码时加几把锁”那么简单，而是一种思维方式，它需要我们从程序整体考虑，而不是局限于单一线程。写好多线程程序需要大量的经验积累！\n层次化设计 在这个单元中，我并没有很好的关注”层次化设计“，大量的逻辑写在了Elevator类中，各种逻辑的耦合导致debug的时候十分痛苦，往往是牵一发而动全身，改好了一个bug可能导致了更多的bug。这也是我需要反思学习、积累经验的，很多时候一个优秀的架构设计往往能避免很多问题。\n其他 多线程编程需要摒弃之前的编程思维，更多的考虑时序关系。单线程程序的执行是线性的，开发者只需要关注代码从上到下的执行逻辑即可；但在多线程环境中，代码的执行顺序不再可控，线程之间可能并发运行、抢占资源，造成不可预测的结果。 很多时候本地无法跑出官方评测机的结果，甚至在本地跑的结果也千奇百怪，这主要是因为我们只能让线程进入就绪状态，而无法控制线程何时执行，这就带来了很多不确定性。最理想的情况当然是确保逻辑严密，JVM无论怎么调度都能保证正确性，但是这需要大量的经验累积和对底层知识的深入理解。 在第三次作业的处理中引入了异步操作导致不确定性进一步增加，而且也有点不符合实际，个人认为是一次比较失败的设计，但是由于时间原因确实没精力再重构了。 在刚学习Java的多线程编程时很多地方都感到困惑，不理解其背后的原理，但是在OS也学到线程和进程后，对很多东西都感到豁然开朗。 原本以为手机上的软件开发没什么难度，但是自己实操了之后才明白，写一个软件不难，但是想写一个支持高并发，能够让几亿人同时使用的软件确实绝非易事，毕竟自己处理6个电梯线程就出现了数不清的bug。 ","date":"2025-04-18T18:28:00Z","image":"https://lhy0424.top/p/oo-unit2/cover_hu_d76e29345edf9cf.jpg","permalink":"https://lhy0424.top/p/oo-unit2/","title":"BUAA-OO-Unit2"},{"content":"BUAA-OS-lab1杂记 字节序（byte order） Little endian(小端)与Big endian(大端)\n“endian”这个词出自 Jonathan Swin 在 1726 年写的讽刺小说《格列佛游记》( Guliver\u0026rsquo;s Travels )，小人国的内战就源于吃水煮鸡蛋时究竟是从大头(Big-Endian)敲开还是从小头(Little-Endian)敲开，由此曾发生过 6 次叛乱，其中一个皇帝送了命，另一个丢了王位。\nMSB（most significant bit/byte）LSB（least significant bit/byte）\nLittle-endian 把MSB存放在高地址，Big-endian把MSB存放在低地址\n例如0x12345678\n0字节 1字节 2字节 3字节 EL 0x78 0x56 0x34 0x12 EB 0x12 0x34 0x56 0x78 Big-endian在内存中的顺序比较符合数字的书写习惯，而Little-endian可以确保在变量指针转换的时候地址保持不变。比如uint32*转换为char*，只需要取0字节即可。\n使用readelf -h可以查看elf header信息，可以看到mos操作系统是Little-endian的。\nELF 程序代码被编译和链接成包含二进制计算机指令的可执行文件。而可执行文件是有格式规范的，在 Linux 中，这个规范叫 Executable and Linkable format (ELF)。ELF 中包含二进制计算机指令、静态数据、元信息。\n从ELF的全称可以看出，ELF文件有两个特性Executable可执行的和Linkable可链接的，对应的ELF文件有两种视角。\nLinking view链接视角，节头表（section header table）包含了链接时所需的信息，告诉操作系统如何链接可执行文件，完成进程内存的初始化。 Execution view执行视角，段头表（program header table）包含了运行时加载程序所需的信息，告诉操作系统如何加载可执行文件，完成进程内存的初始化。一个可执行的ELF一定有program header table。 ELF有三种类型\nrelocatable 可重定位文件 executable 可执行文件 shared object 共享对象文件 readelf c语言中结构体就是一片连续的内存，elf.h文件里的结构体实际上是对内存的一种映射。\n我们在main.c中获得了一个指向ELF文件二进制数据的指针p，接着我们要实现的就是根据ELF文件的结构去解析这些二进制数据。\n解析之前我们需要先判断这些二进制数据是不是ELF文件。\n先假设这些数据是ELF格式的（将指针转换为我们定义的Elf32_Ehdr去读取ELF的文件头），ELF文件头里的e_ident就是用于告诉外界这是一个ELF文件的，我们只需要判断e_ident里是不是特定内容即可。\n1 2 3 4 5 6 int is_elf_format(const void *binary, size_t size) { Elf32_Ehdr *ehdr = (Elf32_Ehdr *)binary; return size \u0026gt;= sizeof(Elf32_Ehdr) \u0026amp;\u0026amp; ehdr-\u0026gt;e_ident[EI_MAG0] == ELFMAG0 \u0026amp;\u0026amp; ehdr-\u0026gt;e_ident[EI_MAG1] == ELFMAG1 \u0026amp;\u0026amp; ehdr-\u0026gt;e_ident[EI_MAG2] == ELFMAG2 \u0026amp;\u0026amp; ehdr-\u0026gt;e_ident[EI_MAG3] == ELFMAG3; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 typedef struct { unsigned char e_ident[EI_NIDENT]; /* Magic number and other info */ Elf32_Half e_type;\t/* Object file type */ Elf32_Half e_machine;\t/* Architecture */ Elf32_Word e_version;\t/* Object file version */ Elf32_Addr e_entry;\t/* Entry point virtual address */ Elf32_Off e_phoff;\t/* Program header table file offset */ Elf32_Off e_shoff;\t/* Section header table file offset */ Elf32_Word e_flags;\t/* Processor-specific flags */ Elf32_Half e_ehsize;\t/* ELF header size in bytes */ Elf32_Half e_phentsize;\t/* Program header table entry size */ Elf32_Half e_phnum;\t/* Program header table entry count */ Elf32_Half e_shentsize;\t/* Section header table entry size */ Elf32_Half e_shnum;\t/* Section header table entry count */ Elf32_Half e_shstrndx;\t/* Section header string table index */ } Elf32_Ehdr; /* Fields in the e_ident array. The EI_* macros are indices into the array. The macros under each EI_* macro are the values the byte may have. */ #define EI_MAG0 0 /* File identification byte 0 index */ #define ELFMAG0 0x7f /* Magic number byte 0 */ #define EI_MAG1 1 /* File identification byte 1 index */ #define ELFMAG1 \u0026#39;E\u0026#39; /* Magic number byte 1 */ #define EI_MAG2 2 /* File identification byte 2 index */ #define ELFMAG2 \u0026#39;L\u0026#39; /* Magic number byte 2 */ #define EI_MAG3 3 /* File identification byte 3 index */ #define ELFMAG3 \u0026#39;F\u0026#39; /* Magic number byte 3 */ 知道了这些二进制数据是一个ELF格式的文件之后我们就可以解析了。课程组需要我们实现的是解析section header table，我们该如何找到section header table呢？显然ELF文件头里已经告诉我们了，且还告诉了我们tabel里有几个header，每个header有多大，我们只需要在当前指针加上一个偏移量即可找到section header table。\n为什么要把binary转换为char类型的指针？\n假设偏移量为1，const void类型的指针不知道1指的是1字节还是1比特，而转换为char类型的指针指示就明确了偏移量的单位是一个char，即一字节。\n1 2 3 4 5 6 7 8 9 10 // Get the address of the section table, the number of section headers and the size of a // section header. const void *sh_table; Elf32_Half sh_entry_count; Elf32_Half sh_entry_size; /* Exercise 1.1: Your code here. (1/2) */ Elf32_Off sh_off = ehdr-\u0026gt;e_shoff; // section header table file offset sh_entry_count = ehdr-\u0026gt;e_shnum; // table entry num sh_entry_size = ehdr-\u0026gt;e_shentsize; // size of each table entry sh_table = (const void *)((char *)binary + sh_off); // move to section header 找到section header table之后输出每个header的地址即可。需要注意的是结构体Elf32_Shdr映射的是一个section header，移动指针的时候需要转换指针类型确保每次移动一个header的长度。\n1 2 3 4 5 6 7 8 9 10 // For each section header, output its index and the section address. // The index should start from 0. for (int i = 0; i \u0026lt; sh_entry_count; i++) { const Elf32_Shdr *shdr; unsigned int addr; /* Exercise 1.1: Your code here. (2/2) */ shdr = (const Elf32_Shdr *)sh_table + i; addr = shdr-\u0026gt;sh_addr; printf(\u0026#34;%d:0x%x\\n\u0026#34;, i, addr); } 1 2 3 4 5 6 7 8 9 10 11 12 13 /* Section segment header. */ typedef struct { Elf32_Word sh_name;\t/* Section name */ Elf32_Word sh_type;\t/* Section type */ Elf32_Word sh_flags;\t/* Section flags */ Elf32_Addr sh_addr;\t/* Section addr */ Elf32_Off sh_offset;\t/* Section offset */ Elf32_Word sh_size;\t/* Section size */ Elf32_Word sh_link;\t/* Section link */ Elf32_Word sh_info;\t/* Section extra info */ Elf32_Word sh_addralign; /* Section alignment */ Elf32_Word sh_entsize;\t/* Section entry size */ } Elf32_Shdr; 加载内核文件 了解了ELF格式之后，我们就要开始学习如何我们的mos操作系统内核了。\n对于32位处理器，MIPS体系结构中的虚拟内存为4GB。\n课程组已经贴心地给出了内存图，我们只需要把各部分放到正确的地址即可。\n根据内存图，我们把.text放到kernel text处（0x80020000），.data和.bss依次放置即可。\n.text 保存可执行文件的操作指令。\n.data 保存已初始化的全局变量和静态变量。\n.bss 保存未初始化的全局变量和静态变量。\n.text .data .bss是ELF中比较重要的三个section。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 /* o 4G -----------\u0026gt; +----------------------------+------------0x100000000 o | ... | kseg2 o KSEG2 -----\u0026gt; +----------------------------+------------0xc000 0000 o | Devices | kseg1 o KSEG1 -----\u0026gt; +----------------------------+------------0xa000 0000 o | Invalid Memory | /|\\ o +----------------------------+----|-------Physical Memory Max o | ... | kseg0 o KSTACKTOP-----\u0026gt; +----------------------------+----|-------0x8040 0000-------end o | Kernel Stack | | KSTKSIZE /|\\ o +----------------------------+----|------ | o | Kernel Text | | PDMAP o KERNBASE -----\u0026gt; +----------------------------+----|-------0x8002 0000 | o | Exception Entry | \\|/ \\|/ o ULIM -----\u0026gt; +----------------------------+------------0x8000 0000------- o | User VPT | PDMAP /|\\ o UVPT -----\u0026gt; +----------------------------+------------0x7fc0 0000 | o | pages | PDMAP | o UPAGES -----\u0026gt; +----------------------------+------------0x7f80 0000 | o | envs | PDMAP | o UTOP,UENVS -----\u0026gt; +----------------------------+------------0x7f40 0000 | o UXSTACKTOP -/ | user exception stack | PTMAP | o +----------------------------+------------0x7f3f f000 | o | | PTMAP | o USTACKTOP ----\u0026gt; +----------------------------+------------0x7f3f e000 | o | normal user stack | PTMAP | o +----------------------------+------------0x7f3f d000 | a | | | a ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ | a . . | a . . kuseg a . . | a |~~~~~~~~~~~~~~~~~~~~~~~~~~~~| | a | | | o UTEXT -----\u0026gt; +----------------------------+------------0x0040 0000 | o | reserved for COW | PTMAP | o UCOW -----\u0026gt; +----------------------------+------------0x003f f000 | o | reversed for temporary | PTMAP | o UTEMP -----\u0026gt; +----------------------------+------------0x003f e000 | o | invalid memory | \\|/ a 0 ------------\u0026gt; +----------------------------+ ---------------------------- o */ SECTIONS { /* Exercise 3.10: Your code here. */ /* fill in the correct address of the key sections: text, data, bss. */ /* Hint: The loading address can be found in the memory layout. And the data section * and bss section are right after the text section, so you can just define * them after the text section. */ /* Step 1: Set the loading address of the text section to the location counter \u0026quot;.\u0026quot;. */ /* Exercise 1.2: Your code here. (1/4) */ . = 0x80020000; /* Step 2: Define the text section. */ /* Exercise 1.2: Your code here. (2/4) */ .text : { *(.text) } /* Step 3: Define the data section. */ /* Exercise 1.2: Your code here. (3/4) */ .data : { *(.data) } bss_start = .; /* Step 4: Define the bss section. */ /* Exercise 1.2: Your code here. (4/4) */ .bss : { *(.bss) } bss_end = .; . = 0x80400000; end = . ; } 其实内存布局并不像内存图画的那样界限分明，.text放到其他地方也是可以正常运行的，比如把.text放到0x80010000也是可以正常运行的，不过最好遵循课程组的要求。\n内核入口 在把对应的section加载到正确的位置后，我们需要考虑如何启动内核。第一步当然是找到内核的入口了。\n打开init目录下的start.S，补全我们的代码，将 sp 寄存器设置到内核栈空间的位置上，随后跳转到 mips_init 函数。\n在kernel.lds文件中我们看到这样一行，其作用是告诉链接器程序的入口地址，即程序执行的第一条指令的地址。\n1 ENTRY(_start) 那么这个_start在哪呢？在start.S文件中我们看到这样一行，其作用是声明一个全局符号_start，使链接器能找到_start。\n1 EXPORT(_start) 在include/asm/asm.h文件下我们可以看到EXPORT宏的展开形式。\n1 2 3 #define EXPORT(symbol) \\ .globl symbol; \\ symbol: 继续往下看，我们看到以下两行代码\n1 2 .set at .set reorder 在上学期的co中，我们在mars里一定看到过一个叫$at的寄存器，其全称是Assembler Temporary，即临时寄存器。\n在mips中有一些指令本身并不是 MIPS 硬件支持的原生指令，而是由汇编器自动翻译成一条或多条真正的 MIPS 指令。比如li指令。\n1 li $t0, 0x12345678 # 伪指令 这条指令会被汇编器翻译为\n1 2 lui $at, 0x1234 ori $t0, $at, 0x5678 这里就用到了at寄存器。.set at指令就是告诉汇编器允许使用at寄存器进行伪指令展开。如果使用了.set noat，那么汇编器再遇到需要使用到at寄存器的伪指令时会报错。\n在co中我们对流水线印象深刻。我们知道一些指令会在不影响结果的情况下被放到延迟槽里执行，这项工作也是由汇编器来完成的，.set reorder指令就是允许汇编器对指令进行重排的，我们也可以使用.set noreorder来禁止汇编器的重排行为。\n完成了一些初始化设置之后，start.S文件会先对.bss区域进行清零操作，即未初始化的全局变量和静态变量初始值为0。这里我们回顾一下c语言中的变量类型。\nstatic类型的int变量存储在.bss（未初始化）和.data（已初始化）生命周期是从主程序的开始到结束，我们每次调用func函数变量c和d都会自增1。需要注意的是，虽然它们的生命周期是整个程序的运行周期，但它们只在其定义的函数内可访问。 普通类型的int变量存储在栈上，其生命周期是从函数的开始到结束，每次进入 func() 时会重新分配内存，并在函数返回时销毁。 普通类型的变量如何没有初始化其数值是不确定的，static类型的变量如果未初始化其数值默认为0。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include\u0026lt;stdio.h\u0026gt; int a = 5;\t// staged in .data int b;\t// staged in .bss void func() { static int c = 1;\t// staged in .data c++; static int d;\t// staged in .bss d++; int e = 7;\t// staged in stack e++; int f;\t// staged in stack f++; printf(\u0026#34;c is %d\\n\u0026#34;, c); printf(\u0026#34;d is %d\\n\u0026#34;, d); printf(\u0026#34;e is %d\\n\u0026#34;, e); printf(\u0026#34;f is %d\\n\\n\u0026#34;, f); } int main() { func(); func(); func(); return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 git@23373112:~/learnClang $ gcc main.c -o main \u0026amp;\u0026amp; ./main c is 2 d is 1 e is 8 f is 32677 c is 3 d is 2 e is 8 f is 32678 c is 4 d is 3 e is 8 f is 32679 .bss清零结束之后，程序会先把CP0状态置为0禁用中断，确保内核的初始化不会被打断，然后把栈指针放到正确的位置，最后跳转到mips_init（init/init.c文件中），对于lab1，mips_init只有打印的功能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 void mips_init(u_int argc, char **argv, char **penv, u_int ram_low_size) { printk(\u0026#34;init.c:\\tmips_init() is called\\n\u0026#34;); // lab2: // mips_detect_memory(ram_low_size); // mips_vm_init(); // page_init(); // lab3: // env_init(); // lab3: // ENV_CREATE_PRIORITY(user_bare_loop, 1); // ENV_CREATE_PRIORITY(user_bare_loop, 2); // lab4: // ENV_CREATE(user_tltest); // ENV_CREATE(user_fktest); // ENV_CREATE(user_pingpong); // lab6: // ENV_CREATE(user_icode); // This must be the first env! // lab5: // ENV_CREATE(user_fstest); // ENV_CREATE(fs_serv); // This must be the second env! // ENV_CREATE(user_devtst); // lab3: // schedule(0); halt(); } 我们在内存图中可以找到kernel stack的位置，但是为什么栈帧要设置在kernel stack的栈顶（KSTACKTOP = 0x8004000）？\n进程地址的分布取决于操作系统，栈向什么方向增长取决于操作系统与CPU的组合。\n是否还记得上学期计算机组成原理中mips是如何在调用函数前保护和恢复寄存器的，是先$sp自减再$sp自增，表明对于mips指令集栈的生长方向是由高地址向低地址生长的。\n至于为什么要这样设定，更多的是历史原因，许多早期处理器在基址寄存器寻址时仅支持无符号偏移，因此如果栈向低地址增长，相对栈指针的地址计算更高效。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;asm/asm.h\u0026gt; #include \u0026lt;mmu.h\u0026gt; .text EXPORT(_start) .set at .set reorder /* Lab 1 Key Code \u0026#34;enter-kernel\u0026#34; */ /* clear .bss segment */ la v0, bss_start la v1, bss_end clear_bss_loop: beq v0, v1, clear_bss_done sb zero, 0(v0) addiu v0, v0, 1 j clear_bss_loop /* End of Key Code \u0026#34;enter-kernel\u0026#34; */ clear_bss_done: /* disable interrupts */ mtc0 zero, CP0_STATUS /* hint: you can refer to the memory layout in include/mmu.h */ /* set up the kernel stack */ /* Exercise 1.3: Your code here. (1/2) */ la sp, KSTACKTOP /* jump to mips_init */ /* Exercise 1.3: Your code here. (2/2) */ j mips_init printk 调用链 完成了之前的工作，我们的内核已经能正常启动了，现在要做的是实现打印功能，即完成printk函数，使mips_init中的printk函数能正确被调用。\n观察init.c的头文件声明部分。\n1 2 3 4 5 6 #include \u0026lt;asm/asm.h\u0026gt; #include \u0026lt;env.h\u0026gt; #include \u0026lt;pmap.h\u0026gt; #include \u0026lt;printk.h\u0026gt; #include \u0026lt;sched.h\u0026gt; #include \u0026lt;trap.h\u0026gt; 显然printk函数的声明在printk.h文件中，下面我们来分析printk.h代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # include/printk.h #ifndef _printk_h_ #define _printk_h_ #include \u0026lt;machine.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; void printk(const char *fmt, ...); void _panic(const char *, int, const char *, const char *, ...) #ifdef MOS_HANG_ON_PANIC __attribute__((noreturn)) #endif ; #define panic(...) _panic(__FILE__, __LINE__, __func__, __VA_ARGS__) #define panic_on(expr) \\ do { \\ int _r = (expr); \\ if (_r != 0) { \\ panic(\u0026#34;\u0026#39;\u0026#34; #expr \u0026#34;\u0026#39; returned %d\u0026#34;, _r); \\ } \\ } while (0) #endif /* _printk_h_ */ 头文件声明部分\n1 2 3 4 #ifndef _printk_h_ #define _printk_h_ // 头文件内容 #endif /* _printk_h_ */ 如果_printk_h_没有被定义则定义_printk_h_，避免重复头文件被重复包含。\n函数声明部分，panic函数是用来处理错误的函数，这里不做过多的解释。\n1 void printk(const char *fmt, ...); 在开发与操作系统内核相关的项目，printk 是内核提供的函数（其中k就是kernel的意思）。此处只有声明没有实现，具体实现在kern/printk.c中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # kern/printk.c #include \u0026lt;print.h\u0026gt; #include \u0026lt;printk.h\u0026gt; #include \u0026lt;trap.h\u0026gt; /* Lab 1 Key Code \u0026#34;outputk\u0026#34; */ void outputk(void *data, const char *buf, size_t len) { for (int i = 0; i \u0026lt; len; i++) { printcharc(buf[i]); } } /* End of Key Code \u0026#34;outputk\u0026#34; */ /* Lab 1 Key Code \u0026#34;printk\u0026#34; */ void printk(const char *fmt, ...) { va_list ap; va_start(ap, fmt); vprintfmt(outputk, NULL, fmt, ap); va_end(ap); } /* End of Key Code \u0026#34;printk\u0026#34; */ void print_tf(struct Trapframe *tf) { for (int i = 0; i \u0026lt; sizeof(tf-\u0026gt;regs) / sizeof(tf-\u0026gt;regs[0]); i++) { printk(\u0026#34;$%2d = %08x\\n\u0026#34;, i, tf-\u0026gt;regs[i]); } printk(\u0026#34;HI = %08x\\n\u0026#34;, tf-\u0026gt;hi); printk(\u0026#34;LO = %08x\\n\\n\u0026#34;, tf-\u0026gt;lo); printk(\u0026#34;CP0.SR = %08x\\n\u0026#34;, tf-\u0026gt;cp0_status); printk(\u0026#34;CP0.BadV = %08x\\n\u0026#34;, tf-\u0026gt;cp0_badvaddr); printk(\u0026#34;CP0.Cause = %08x\\n\u0026#34;, tf-\u0026gt;cp0_cause); printk(\u0026#34;CP0.EPC = %08x\\n\u0026#34;, tf-\u0026gt;cp0_epc); } 然后我们发现printk函数又调用了vprintfmt函数，继续跳转到vprintfmt的实现（include/print.h）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # include/print.h #ifndef _print_h_ #define _print_h_ #include \u0026lt;stdarg.h\u0026gt; #include \u0026lt;types.h\u0026gt; typedef void (*fmt_callback_t)(void *data, const char *buf, size_t len); /* Lab 1 Key Code \u0026#34;vprintfmt-overview\u0026#34; */ /* * \u0026#39;vprintfmt\u0026#39; is a formatting function that allows different backends (i.e., output sinks) * to be used for printing. It takes four arguments: * * - \u0026#39;fmt_callback_t out\u0026#39;: a function pointer to the output sink that receives the * formatted output generated by \u0026#39;vprintfmt\u0026#39;. * - \u0026#39;void *data\u0026#39;: a context pointer passed to the \u0026#39;out\u0026#39; callback function. It can be used * to store additional output sink-specific data. * - \u0026#39;const char *fmt\u0026#39;: the format string, similar to the format string in \u0026#39;printf\u0026#39;. * - \u0026#39;va_list ap\u0026#39;: a variadic argument list that provides the arguments to be formatted. * * The format callback function \u0026#39;out\u0026#39; receives the following arguments: * * - \u0026#39;void *data\u0026#39;: the same \u0026#39;data\u0026#39; pointer passed to \u0026#39;vprintfmt\u0026#39;. * - \u0026#39;const char *buf\u0026#39;: a pointer to a buffer containing the formatted output. * - \u0026#39;size_t len\u0026#39;: the number of bytes in the buffer. * * Note that the buffer may not be null-terminated and may contain embedded null bytes, * so the output sink should treat \u0026#39;len\u0026#39; as the actual length of the buffer to print. */ void vprintfmt(fmt_callback_t out, void *data, const char *fmt, va_list ap); /* End of Key Code \u0026#34;vprintfmt-overview\u0026#34; */ #endif typedef 定义了一个名为 fmt_callback_t 的类型，它是一个函数指针类型，指向一个接受 void *data、const char *buf 和 size_t len 作为参数的函数。\n截止又是只声明了vprintfmt函数但是没有实现，我们继续找，在lib目录下的print.c文件中我们终于找到了vprintfmt的实现，也正是我们需要填空的部分。\n先解释下函数名vprintfmt，v代表\u0026quot;variadic\u0026quot;（可变参数），fmt代表format格式化，即这是一个支持可变参数并且进行格式化输出的函数。\n再来看vprintfmt的传入参数\nfmt_callback_t out回调函数，往前追溯我们发现这个参数在调用时传入的是outputk函数，即遍历buf，每次输出一个char。我们可以理解为一个无格式好打印字符串的函数。 void *data指向任意类型的指针，可以用于传递给回调函数的上下文信息。在回调函数中，data 可以用来存储或传递与输出相关的附加数据（比如输出目的地、日志上下文等），但是在lab1中并没有涉及相关处理。 const char *fmt格式化字符串，也就是类似\u0026quot;a is %d\u0026quot;这样带有%d等占位符的字符串。 va_list ap可变参数列表，包含我们用来替换占位符的数据。 我们要做的就是解析格式化字符串fmt，将其中%[flags][width][length]\u0026lt;specifier\u0026gt;形式的格式符替换为正确的字符串，具体代码如下，遇到%就将之前的字符串输出，然后解析格式符利用已有函数输出（print_num、print_char等等），直到遇到\\0结束循环。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 # lib/print.c #include \u0026lt;print.h\u0026gt; /* forward declaration */ static void print_char(fmt_callback_t, void *, char, int, int); static void print_str(fmt_callback_t, void *, const char *, int, int); static void print_num(fmt_callback_t, void *, unsigned long, int, int, int, int, char, int); void vprintfmt(fmt_callback_t out, void *data, const char *fmt, va_list ap) { char c; const char *s; long num; int width; int long_flag; // output is long (rather than int) int neg_flag; // output is negative int ladjust; // output is left-aligned char padc; // padding char for (;;) { /* scan for the next \u0026#39;%\u0026#39; */ /* Exercise 1.4: Your code here. (1/8) */ const char *p = fmt; while (*p != \u0026#39;%\u0026#39; \u0026amp;\u0026amp; *p != \u0026#39;\\0\u0026#39;) { p++; } /* flush the string found so far */ /* Exercise 1.4: Your code here. (2/8) */ out(data, fmt, p - fmt); fmt = p; /* check \u0026#34;are we hitting the end?\u0026#34; */ /* Exercise 1.4: Your code here. (3/8) */ if (*fmt == \u0026#39;\\0\u0026#39;) { break; } /* we found a \u0026#39;%\u0026#39; */ /* Exercise 1.4: Your code here. (4/8) */ fmt++; /* check format flag */ /* Exercise 1.4: Your code here. (5/8) */ ladjust = 0; padc = \u0026#39; \u0026#39;; if (*fmt == \u0026#39;-\u0026#39;) { ladjust = 1; fmt++; } else if (*fmt == \u0026#39;0\u0026#39;) { padc = \u0026#39;0\u0026#39;; fmt++; } /* get width */ /* Exercise 1.4: Your code here. (6/8) */ width = 0; while (*fmt \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; *fmt \u0026lt;= \u0026#39;9\u0026#39; \u0026amp;\u0026amp; *fmt != \u0026#39;\\0\u0026#39;) { width *= 10; width += *fmt - \u0026#39;0\u0026#39;; fmt++; } /* check for long */ /* Exercise 1.4: Your code here. (7/8) */ long_flag = 0; if (*fmt == \u0026#39;l\u0026#39;) { long_flag = 1; fmt++; } neg_flag = 0; switch (*fmt) { case \u0026#39;b\u0026#39;: if (long_flag) { num = va_arg(ap, long int); } else { num = va_arg(ap, int); } print_num(out, data, num, 2, 0, width, ladjust, padc, 0); break; case \u0026#39;d\u0026#39;: case \u0026#39;D\u0026#39;: if (long_flag) { num = va_arg(ap, long int); } else { num = va_arg(ap, int); } /* * Refer to other parts (case \u0026#39;b\u0026#39;, case \u0026#39;o\u0026#39;, etc.) and func \u0026#39;print_num\u0026#39; to * complete this part. Think the differences between case \u0026#39;d\u0026#39; and the * others. (hint: \u0026#39;neg_flag\u0026#39;). */ /* Exercise 1.4: Your code here. (8/8) */ if (num \u0026lt; 0) { neg_flag = 1; num = -num; } print_num(out, data, num, 10, neg_flag, width, ladjust, padc, 0); break; case \u0026#39;o\u0026#39;: case \u0026#39;O\u0026#39;: if (long_flag) { num = va_arg(ap, long int); } else { num = va_arg(ap, int); } print_num(out, data, num, 8, 0, width, ladjust, padc, 0); break; case \u0026#39;u\u0026#39;: case \u0026#39;U\u0026#39;: if (long_flag) { num = va_arg(ap, long int); } else { num = va_arg(ap, int); } print_num(out, data, num, 10, 0, width, ladjust, padc, 0); break; case \u0026#39;x\u0026#39;: if (long_flag) { num = va_arg(ap, long int); } else { num = va_arg(ap, int); } print_num(out, data, num, 16, 0, width, ladjust, padc, 0); break; case \u0026#39;X\u0026#39;: if (long_flag) { num = va_arg(ap, long int); } else { num = va_arg(ap, int); } print_num(out, data, num, 16, 0, width, ladjust, padc, 1); break; case \u0026#39;c\u0026#39;: c = (char)va_arg(ap, int); print_char(out, data, c, width, ladjust); break; case \u0026#39;s\u0026#39;: s = (char *)va_arg(ap, char *); print_str(out, data, s, width, ladjust); break; case \u0026#39;\\0\u0026#39;: fmt--; break; default: /* output this char as it is */ out(data, fmt, 1); } fmt++; } } /* --------------- local help functions --------------------- */ void print_char(fmt_callback_t out, void *data, char c, int length, int ladjust) { int i; if (length \u0026lt; 1) { length = 1; } const char space = \u0026#39; \u0026#39;; if (ladjust) { out(data, \u0026amp;c, 1); for (i = 1; i \u0026lt; length; i++) { out(data, \u0026amp;space, 1); } } else { for (i = 0; i \u0026lt; length - 1; i++) { out(data, \u0026amp;space, 1); } out(data, \u0026amp;c, 1); } } void print_str(fmt_callback_t out, void *data, const char *s, int length, int ladjust) { int i; int len = 0; const char *s1 = s; while (*s1++) { len++; } if (length \u0026lt; len) { length = len; } if (ladjust) { out(data, s, len); for (i = len; i \u0026lt; length; i++) { out(data, \u0026#34; \u0026#34;, 1); } } else { for (i = 0; i \u0026lt; length - len; i++) { out(data, \u0026#34; \u0026#34;, 1); } out(data, s, len); } } void print_num(fmt_callback_t out, void *data, unsigned long u, int base, int neg_flag, int length, int ladjust, char padc, int upcase) { /* algorithm : * 1. prints the number from left to right in reverse form. * 2. fill the remaining spaces with padc if length is longer than * the actual length * TRICKY : if left adjusted, no \u0026#34;0\u0026#34; padding. *\tif negtive, insert \u0026#34;0\u0026#34; padding between \u0026#34;0\u0026#34; and number. * 3. if (!ladjust) we reverse the whole string including paddings * 4. otherwise we only reverse the actual string representing the num. */ int actualLength = 0; char buf[length + 70]; char *p = buf; int i; do { int tmp = u % base; if (tmp \u0026lt;= 9) { *p++ = \u0026#39;0\u0026#39; + tmp; } else if (upcase) { *p++ = \u0026#39;A\u0026#39; + tmp - 10; } else { *p++ = \u0026#39;a\u0026#39; + tmp - 10; } u /= base; } while (u != 0); if (neg_flag) { *p++ = \u0026#39;-\u0026#39;; } /* figure out actual length and adjust the maximum length */ actualLength = p - buf; if (length \u0026lt; actualLength) { length = actualLength; } /* add padding */ if (ladjust) { padc = \u0026#39; \u0026#39;; } if (neg_flag \u0026amp;\u0026amp; !ladjust \u0026amp;\u0026amp; (padc == \u0026#39;0\u0026#39;)) { for (i = actualLength - 1; i \u0026lt; length - 1; i++) { buf[i] = padc; } buf[length - 1] = \u0026#39;-\u0026#39;; } else { for (i = actualLength; i \u0026lt; length; i++) { buf[i] = padc; } } /* prepare to reverse the string */ int begin = 0; int end; if (ladjust) { end = actualLength - 1; } else { end = length - 1; } /* adjust the string pointer */ while (end \u0026gt; begin) { char tmp = buf[begin]; buf[begin] = buf[end]; buf[end] = tmp; begin++; end--; } out(data, buf, length); } 回顾一下整个调用链\n1 2 graph TD printk --\u0026gt; include/printk.h --\u0026gt; kern/printk.c --\u0026gt; include/print.h --\u0026gt; lib/print.c include目录：目录通常包含所有的头文件，这些头文件提供了函数声明、宏、结构体定义和常量等，这些头文件为内核的各个模块提供了接口，使得不同模块之间可以共享信息和功能。 kern目录：通常包含与内核核心功能（如进程调度、内存管理、系统调用等）相关的实现代码。它主要是内核的实现部分。 lib目录：包含实现内核中通用功能和服务的库函数。它通常存放一些通用的辅助代码，这些代码可以被多个内核模块共享。它通常不涉及具体的硬件操作，而是提供一些基础的功能支持，例如字符串操作、内存管理、数学计算等。 需要注意，我们实现的是printk函数，而不是printf函数，虽然二者很像。\nprintk：用于内核空间，是内核中的一个函数，输出到内核日志缓冲区，通常不会直接显示在用户的终端上。 printf：用于用户空间，是C标准库的一部分，输出到标准输出（stdout），通常是用户的终端。 如何理解调用链？\n我们要在一个文件中使用printk函数，就必须使用引入include文件夹里的printk.h头文件，至于它是如何实现的并不是程序员需要关心。\n当链接器看到头文件中声明了printk函数时，它会查找所有目标文件，找到 printk 函数的实际实现（kern/printk.c 中），并将其与其他部分链接在一起。\n在kern/printk.c中实现了printk函数，而printk的实现需要用到vprintfmt函数，这个函数在include/print.h中声明，但是仍然没有实现。\n当链接器看到头文件中声明了vprintfmt函数时，它会查找所有目标文件，找到vprintfmt函数的实际实现（lib/print.c 中），并将其与其他部分链接在一起。\n可变参数 printk的具体实现中，...代表可变参数，即后面有数量未知的参数。\n1 2 3 4 5 6 void printk(const char *fmt, ...) { va_list ap; va_start(ap, fmt); vprintfmt(outputk, NULL, fmt, ap); va_end(ap); } va_xxx是stdarg.h 库中的宏，stdarg.h是C标准库，我们在路径/usr/lib/gcc-cross/mips-linux-gnu/12/include下可以找到这个文件，具体实现细节比较复杂，笔者也没有看懂，感兴趣的可以自行研究。\nva_list：用来声明一个变量，用于保存可变参数的列表。\nva_start(va_list args, last_fixed_arg)：初始化 va_list 变量，告诉宏从哪个固定参数开始提取可变参数。last_fixed_arg 是在参数列表中的最后一个固定参数。必须调用 va_start 来初始化 va_list，否则无法访问可变参数。\nva_arg(va_list args, type)：访问可变参数列表中的下一个参数。type 是你希望获取的参数类型，每次调用 va_arg 后，指针都会向后移动。\nva_end(va_list args)：用于结束对可变参数的访问。调用完 va_arg 后，必须调用 va_end 来清理资源。\n结语 lab1的课下练习，如果仅仅是完成填空是很容易的，但是如果要理解内核中的每一行代码在干什么是一件很费时间（同时也很有趣）的事情。希望同学们能够保持好奇，不仅仅拘泥于完成练习，积极探索操作系统的魅力。\n","date":"2025-03-21T17:00:00Z","image":"https://lhy0424.top/p/os-lab1/cover_hu_94a4862eeabe24f4.jpg","permalink":"https://lhy0424.top/p/os-lab1/","title":"BUAA-OS-lab1杂记"},{"content":"BUAA-OO-Unit1总结 三次迭代回顾 HW1 本次作业需要完成的任务为：读入一个包含加、减、乘、乘方以及括号（其中括号的深度至多为 1 层）的单变量表达式，输出恒等变形展开所有括号后的表达式。\n在本次作业中，展开所有括号的定义是：对原输入表达式 EE 做恒等变形，得到新表达式 E′E′，且 E′E′ 中不含有字符 ( 、 )和空白字符 。\nHW2 本次作业中需要完成的任务为：读入自定义递推函数的定义以及一个包含幂函数、三角函数、自定义递推函数调用的表达式，输出恒等变形展开所有括号后的表达式。\n在本次作业中，展开所有括号的定义是：对原输入表达式 EE 做恒等变形，得到新表达式 E′E′。其中，E′E′ 中不再含有自定义递推函数，且只包含必要的括号（必要括号的定义见公测说明-正确性判定）。\nHW3 本次作业中需要完成的任务为：读入一系列自定义函数的定义以及一个包含幂函数、三角函数、自定义函数调用、求导算子的表达式，输出恒等变形展开所有括号后的表达式。\n在本次作业中，展开所有括号的定义是：对原输入表达式 EE 做恒等变形，得到新表达式 E′E′。其中，E′E′ 中不再含有自定义函数，不再含有求导算子，且只包含必要的括号（必要括号的定义见公测说明-正确性判定）。\n在本次作业中，自定义函数 指自定义递推函数和自定义普通函数。\n设计思路 对于一个很复杂的表达式，我们该如何解析？\n根据递归下降的思路，我们把表达式分为expr（表达式）、term（项）和factor（因子）。\nterm通过 \u0026lsquo;+\u0026rsquo; 或 \u0026lsquo;-\u0026rsquo; (不被括号包裹的加减号) 连接构成expr\n为了简化分割过程，我们可以把所有的 \u0026lsquo;-\u0026rsquo; 替换为 \u0026lsquo;+-\u0026rsquo;，把 \u0026lsquo;-\u0026rsquo; 看作项的一部分，从而可以只根据 \u0026lsquo;+\u0026rsquo; (不被括号包裹的加号)分割 。 factor通过 \u0026lsquo;*\u0026rsquo; (不被括号包裹的乘号) 连接构成term。\n上述两个基本原则是我们解析表达式的关键，基于这两个原则我们可以从expr中提取若干term，从term中提取若干factor。\n笔者舍弃了传统的Lexer和Parser，我认为解析Expr的方法就应该在Expr类里，在new一个Expr的实例的时候就提取出表达式里的term，构成一个ArrayList\u0026lt;Term\u0026gt;作为该Expr实例的一个属性。同理，在new一个Term的实例时候就提取出项里的factor，构成一个ArrayList\u0026lt;Factor\u0026gt;作为该Term实例的一个属性。\n1 2 3 4 5 6 7 8 9 10 public class Expr { private ArrayList\u0026lt;Term\u0026gt; terms = new ArrayList\u0026lt;\u0026gt;(); public Expr(String expr) { terms = extractTerms(); ... } public ArrayList\u0026lt;Term\u0026gt; extractTerms() {...} } 1 2 3 4 5 6 7 8 9 10 public class Term { private ArrayList\u0026lt;Factor\u0026gt; factors = new ArrayList\u0026lt;\u0026gt;(); public Term(String term) { this.factors = extractFactors(); ... } private ArrayList\u0026lt;Factor\u0026gt; extractFactors() {...} } 因子有好多类型，该如何处理？\n使用抽象类+工厂模式\n各类因子（ExprFactor、powFactor等等）继承抽象类Factor，这样Term里的存储因子的ArrayList\u0026lt;Factor\u0026gt;就可以存储各类因子了。\n但是我们在new一个Factor的时候是不知道这个Factor的类型的，而不同因子又有不同的方法和属性，所以我们需要一个工厂，我们传入一个因子的字符串，工厂为我们提供对应类型的因子。\n至于如何判断因子的种类，我采用的是正则匹配的方法，指导书中给出了明确的形式化表述，所以我们根据其要求构造正则表达式即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class FactorFactory { public static Factor getFactor(String s) { ... if (constRe.matcher(s).matches()) { return new ConstFactor(s); } else if (powerRe.matcher(s).matches()) { return new PowerFactor(s); } else if (sinRe.matcher(s).matches() || cosRe.matcher(s).matches()) { return new SinCosFactor(s); } else if (recursiveFuncRe.matcher(s).matches()) { return new RecursiveFuncFactor(s); } else { ... } } } 在得到了表达式树之后如何化简？\n用我们小学二年级就学到的思路，把每个因子都化成单项式，然后合并同类项。\n在第二次作业添加了三角函数之后，表达式化简后的最小不可分单元不再是单项式，需要重新定义最小单元：AtomElement。 $$\r\\sum (coe*x^{pow}*\\prod sin(factor)^{pow}\\prod cos(factor)^{pow})\r$$ 1 2 3 4 5 6 7 public class AtomicElement { private BigInteger coe; private final int xPow; private final int yPow; private final ArrayList\u0026lt;SinCosFactor\u0026gt; triFactors = new ArrayList\u0026lt;\u0026gt;(); ... } 为什么BigInteger没有用final修饰，因为coe系数会有取相反数的操作。 为什么会有一个yPow，那是因为后续的函数定义解析过程中会出现y项，不过结果中不会出现y项。 定义了最小单元之后我们如何获得AtomElement呢？\n为了规范和统一，我们定义一个接口，要求能被转化为AtomElement的类（Expr、Term、Factor）都必须实现一个获得ArrayList\u0026lt;AtomElement\u0026gt;的方法。\n我们规定Expr/Term/Factor等价于对应getAtomicElement()得到的ArrayList\u0026lt;AtomElement\u0026gt;中的每个元素相加。\nexpr的getAtomicElements()方法需要调用其包含的每一个term的getAtomElements()方法，每一个term又需要调用其包含的每一个factor的getAtomElements()方法，然后一层层返回最终得到表达式expr包含的所有AtomElement，合并可以合并的AtomElement之后再把每一个AtomElement转化为字符串再用 \u0026lsquo;+\u0026rsquo; 相连即得到最终的化简结果。\n1 2 3 public interface AtomicArrayConvertible { ArrayList\u0026lt;AtomicElement\u0026gt; getAtomicElements(); } 求导该如何解决？\n由于作业中规定求导因子的dx(\u0026hellip;)括号内为一个表达式，我们可以仿照getAtomicElements()的思路，再定义一个Derivable接口，所有可导的东西都需要实现这个接口中的derive方法。\n我们同样需要规定Expr/Term/Factor求导后的结果等价于对应derive()得到的ArrayList\u0026lt;AtomElement\u0026gt;中的每个元素相加。\n遇到一个求导因子，我们获取其最外层括号内的内容，构造一个expr实例，然后调用这个expr的derive()方法，expr的derive()方法需要调用其包含的每一个term的derive()方法，每一个term又需要调用其包含的每一个factor的derive()方法，然后一层层返回最终得到表达式expr包含的所有AtomElement，合并可以合并的AtomElement之后再把每一个AtomElement转化为字符串再用 \u0026lsquo;+\u0026rsquo; 相连即得到最终的求导结果。\n需要注意，求导因子也需要实现derive方法，即可以对一个求导因子再求导。\n1 2 3 public interface Derivable { ArrayList\u0026lt;AtomicElement\u0026gt; derive(); } 递归函数该如何解决？\n由于指导书限制了每次最多只会定义一个递归函数，所以我们可以再递归函数因子下用一个static类型的HashMap存储递归函数的三条定义（f{0}, f{1}, f{n}），key为函数的序号，value为\u0026rsquo;=\u0026lsquo;后的函数表达式。至于形参我们再用一个static类型的ArrayList\u0026lt;String\u0026gt;来存，因为在一个递归函数定义中形参都是一样的。\n在输入递归函数定义时，我们把定义存入HashMap中。在遇到递归函数因子时，我们先判断其序号是否在map中\n如果map中有对应的序号key，则直接把对应的value（函数表达式）取出，将形参替换为实参后构造一个Expr类型的实例，然后利用Expr的getAtomicElement()得到化简结果返回即可。 如果map中没有对应的序号key，这是需要根据f{n}的规则进行递归解析，把n-1和n-2替换为对应的序号，再传入实参得到一个改造后的字符串，利用这个字符串构造Expr，调用Expr的getAtomicElements()即可得到结果。 普通函数呢？\n大致思路和递归函数一样，都是字符串替换后再解析的思路。但是需要注意的是，作业中规定普通函数定义最多有两个，这两个函数的形参可能不一样，我们可以用一个static类型的HashMap\u0026lt;String, ArrayList\u0026lt;String\u0026gt;\u0026gt;存储每个函数对应的形参，其中key是函数名g或者h，value是形参的list。\n在递归函数和普通函数用实参替换形参的过程中都涉及到一个问题，那就是第一个形参的替换不能影响第二个形参的替换，举个例子\nf{1}(x,y) = x + y\nf{1}(y,x)应该等于y + x，而遍历替换的时候会出现下述情况\n(1) f{1}(y,x) = y + y (x被替换为实参y)\n(2) f{1}(y,x) = x + x (y被替换为实参x)\n我们可以引入一个中间量z来解决这个问题\n(1) f{1}(x,z) = x + z (变换函数定义，第二个形参y替换为中间量z)\n(2) f{1}(y,x) = y + z (把第一个形参x都替换为实参y)\n(3) f{1}(y,x) = y + x (把第二个形参z都替换为实参x)\n因为理论上两个形参应该是同时被替换的，但是在实现过程中这样并不可信，我们只能通过遍历的方式去替换，但最终要做到同时替换的效果，具体实现代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 private String replaceParam(String s, ArrayList\u0026lt;String\u0026gt; actualParamList) { int idx = 0; String secondParam = \u0026#34;\u0026#34;; String result = s; if (formalParamList.size() \u0026gt; 1) { secondParam = formalParamList.get(1); result = result.replaceAll(secondParam, \u0026#34;z\u0026#34;); formalParamList.set(1, \u0026#34;z\u0026#34;); } // 代入实参 for (String param: formalParamList) { result = result.replaceAll(param, \u0026#34;(\u0026#34; + actualParamList.get(idx) + \u0026#34;)\u0026#34;); idx++; } result = result.replaceAll(\u0026#34;z\u0026#34;, secondParam); if (formalParamList.size() \u0026gt; 1) { formalParamList.set(1, secondParam); } return result; } 至此，整个框架已经搭建好了，我们只需要根据前面的规定实现对应的函数功能即可。\n新增迭代场景展望 新增自定义变量因子，原变量因子之可能出现变量\u0026rsquo;x\u0026rsquo;，不妨让用户自定义变量名和变量数\n1 2 3 4 5 6 7 8 9 example input: 3 a b var a^3 + a*(var + a)^2 + sin(a^3-b-a^3)^2 expected output: 2*a^3 + 2*var*a^2 + var^2*a + sin(b)^2 在这个新场景中，需要\n修改term提取factor的规则 修改FactorFactory中关于变量因子的正则表达式 新增AtomicElement的属性，每个变量的幂次 修改合并同类相的逻辑 优化分析 CTLE 在处理复杂结构时会出现超时的情况，通过添加cache缓存可以加快程序的运行速度。\n所谓缓存就是把已经计算出的结果储存起来，再次使用的时候不需要重复计算，直接取出之前的结果即可。\n需要确保缓存的内容不会被修改，如果必须被修改则缓存也需要被修改。 因为未改动程序的逻辑，所以并不会影响程序的正确性。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Expr implements AtomicArrayConvertible, Derivable { private ArrayList\u0026lt;AtomicElement\u0026gt; cachedAtoms = new ArrayList\u0026lt;\u0026gt;(); ... @Override public ArrayList\u0026lt;AtomicElement\u0026gt; getAtomicElements() { if (!cachedAtoms.isEmpty()) { return cachedAtoms; } /*process of getting atoms*/ cachedAtoms = atoms; return cachedAtoms; } ... } MLE / OOM 利用Eclipse Memory Analyse Tools分析Java堆，排查OutOfMemory (OOM)的问题。\n把未化简的字符串当成了map的key，且合并同类项的逻辑有问题，导致HashMap中存在大量的键值对，把字符串化简之后再当作key并优化化简逻辑之后轻松解决OOM的问题。\n只需要确保优化前后结果的等价性即不会影响程序的正确性。 程序度量分析 UML 代码行数 从代码量可以看出，最复杂的部分应该就是三角函数，因为三角函数因子无论是解析还是化简求导都是所有因子中最复杂的。 类的分析 CBO (Coupling Between Objects 对象耦合度) = 6.93 中等耦合，可接受 LCOM (Lack of Cohesion of Methods 方法内聚性缺失) = 1.57 低内聚，类可能需要拆分 显然本次本次作业并没有很好的实现\u0026quot;高内聚低耦合\u0026quot;的理想设计目标。 方法复杂度 复杂度过高的方法一般都是字符串处理或者获取特定ArrayList，这主要是因为这两种情况处理比较复杂，有许多需要特判的情况，使用了大量的if-else语句。 自己的bug 双形参函数在替换实参的过程中，第一个形参的替换影响了第二个形参的替换。具体原因在思路介绍的时候已经提出了，通过引入一个中间量z解决。 获取函数形参的时候仅通过 \u0026lsquo;,\u0026rsquo; 来分割，在遇到形如f{2}( f{1}(x,y), x)的因子时会解析错误，解决方法是在最外层括号内部遇到 \u0026lsquo;,\u0026rsquo; 时判断一下是否被括号所包裹，如果不被包裹则分割获得形参。 求导因子内部的derive()方法思路错误，这个方法应该是对求导因子再求导，而不是返回求导因子的结果，导致无法处理嵌套求导。修复derive()方法的逻辑即可。 出现这些bug的主要原因是写代码时没有全面的考虑可能出现的情况，想到什么就写什么，后续也没有进行充分的测试。可以通过编写测试单元、构造多样数据进行充分测试尽可能避免类似的bug。\n如何发现别人程序bug 评测机随机大量数据测试 找到错误后查看源代码定位问题 针对特定问题想出较为简单的测试数据提交hack 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 # hw2数据生成代码思路 class DataMakerH2: # 生成一个随机幂 def _rand_power(self, isY): # 生成一个随机表达式因子 def _rand_expr_factor(self, isY, hasRecursiveFactor, formal_param): # 生成一个随机三角函数因子 def _rand_sin_cos(self, isY, hasRecursiveFactor, formal_param): # 生成一个随机因子 def _rand_factor(self, isY, hasRecursiveFactor=False, formal_param=\u0026#34;\u0026#34;): rand = random.random() if rand \u0026lt; 0.2 and self.inBrackets \u0026lt; 3: return self._rand_expr_factor(isY, hasRecursiveFactor, formal_param) elif rand \u0026lt; 0.4 and hasRecursiveFactor: return self._rand_recursive_factor(formal_param) elif rand \u0026lt; 0.6: return self._rand_signed_int() elif rand \u0026lt; 0.8 and self.inBrackets \u0026lt; 3: return self._rand_sin_cos(isY, hasRecursiveFactor, formal_param) else: return self._rand_power(isY) # 生成一个随机项 def _rand_term(self, isY, hasRecursiveFactor, formal_param): # 生成一个随机表达式 def _rand_expr(self, isY, hasRecursiveFactor, formal_param): # 生成一个单独的表达式 def _generate_single_expr(self, isY ,hasRecursiveFactor, formal_param): # 生成f{0}和f{1}的表达式 def _rand_func_expr(self, formal_param): if formal_param == \u0026#34;x,y\u0026#34; or formal_param == \u0026#34;y,x\u0026#34;: func_expr = self._rand_expr(isY=True, hasRecursiveFactor=False, formal_param=formal_param) if random.random() \u0026lt; 0.5: func_expr += self._rand_expr(isY=False, hasRecursiveFactor=False, formal_param=formal_param) elif formal_param == \u0026#34;y\u0026#34;: func_expr = self._rand_expr(isY = True, hasRecursiveFactor=False, formal_param=formal_param) else: func_expr = self._rand_expr(isY = False, hasRecursiveFactor=False, formal_param=formal_param) return func_expr # 生成f{n}的表达式 def _rand_recursive_func_expr(self, formal_param): if formal_param == \u0026#34;x,y\u0026#34; or formal_param == \u0026#34;y,x\u0026#34;: sub1_expr = str(random.randint(-10, 10)) + \u0026#34;*f{n-1}\u0026#34; + \u0026#34;(\u0026#34; + self._rand_factor(isY=False) + \u0026#34;, \u0026#34; + self._rand_factor(isY = True) + \u0026#34;)\u0026#34; sub2_expr = str(random.randint(-10, 10)) + \u0026#34;*f{n-2}\u0026#34; + \u0026#34;(\u0026#34; + self._rand_factor(isY=False) + \u0026#34;, \u0026#34; + self._rand_factor(isY = True) + \u0026#34;)\u0026#34; elif formal_param == \u0026#34;x\u0026#34;: sub1_expr = str(random.randint(-10, 10)) + \u0026#34;*f{n-1}\u0026#34; + \u0026#34;(\u0026#34; + self._rand_factor(isY=False) + \u0026#34;)\u0026#34; sub2_expr = str(random.randint(-10, 10)) + \u0026#34;*f{n-2}\u0026#34; + \u0026#34;(\u0026#34; + self._rand_factor(isY=False) + \u0026#34;)\u0026#34; else: sub1_expr = str(random.randint(-10, 10)) + \u0026#34;*f{n-1}\u0026#34; + \u0026#34;(\u0026#34; + self._rand_factor(isY = True) + \u0026#34;)\u0026#34; sub2_expr = str(random.randint(-10, 10)) + \u0026#34;*f{n-2}\u0026#34; + \u0026#34;(\u0026#34; + self._rand_factor(isY = True) + \u0026#34;)\u0026#34; return sub1_expr + \u0026#34;+\u0026#34; + sub2_expr # 生成一个随机递归规则 def _rand_recursive_rule(self, formal_param): # 生成一个随机递归函数因子 def _rand_recursive_factor(self, formal_param): # 生成一个包含递归函数的测试点 def _rand_recursive_example(self): 心得体会 对面向对象的思想（封装、继承和多态）有了更深层次的理解，能够在实际编码中合理运用，例如通过封装提高代码的模块化，通过继承实现代码复用，以及通过多态增强系统的扩展性和灵活性。 对工厂模式的理解更加深入，能够在合适的场景下运用工厂模式来解耦对象的创建过程，提高代码的可维护性和可扩展性，从而实现更灵活的设计。 在不断迭代的过程中认识到了规范的重要性，遵循一些设计规范和命名规则，不但能提高效率，还能减少错误。 通过不断的迭代和小范围重构，深刻认识到了程序可扩展性的重要性，写代码时不仅要考虑当下的要求，还需要考虑后续可能会有哪些新的要求。 通过自己编写评测机，对数据生成的流程和方法有了更全面的认识，深入理解了如何设计高效的数据生成策略，以确保测试数据的多样性和合理性。 真切感受到了自己代码能力的提高。 未来方向 希望能简化一些限制，指导书写的简洁明了一点，减少学生在阅读指导书上花的时间，把更多的精力放在代码设计上。 ","date":"2025-03-19T12:26:00Z","image":"https://lhy-blog-image.oss-cn-beijing.aliyuncs.com/undefinedundefinedimage7-1.png","permalink":"https://lhy0424.top/p/oo-unit1/","title":"BUAA-OO-Unit1"},{"content":"OS-lab0 实验报告 思考题 Thinking 0.1 在前述已初始化的 ~/learnGit 目录下，创建一个名为 README.txt 的文件。执 行命令 git status \u0026gt; Untracked.txt（其中的 \u0026gt; 为输出重定向，我们将在 0.6.3 中 详细介绍）。 在 README.txt 文件中添加任意文件内容，然后使用 add 命令，再执行命令 git status \u0026gt; Stage.txt。 提交 README.txt，并在提交说明里写入自己的学号。 执行命令 cat Untracked.txt 和 cat Stage.txt，对比两次运行的结果，体会 README.txt 两次所处位置的不同。 修改 README.txt 文件，再执行命令 git status \u0026gt; Modified.txt。 执行命令 cat Modified.txt，观察其结果和第一次执行 add 命令之前的 status 是 否一样，并思考原因。 不一样，新建一个文件但不git add，README.txt处于未跟踪状态；git add之后会跟踪README.txt文件，此时文件处于已暂存状态；提交后修改README.txt文件，此时文件处于已修改状态，但是还未添加到暂存区。\nThinking 0.2 仔细看看0.10，思考一下箭头中的 add the file 、stage the file 和 commit 分别对应的是 Git 里的哪些命令呢？\nadd the file对应git add，stage the file对应git add，commit对应git commit\nThinking 0.3 思考下列问题：\n代码文件 print.c 被错误删除时，应当使用什么命令将其恢复？ 代码文件 print.c 被错误删除后，执行了 git rm print.c 命令，此时应当 使用什么命令将其恢复？ 无关文件 hello.txt 已经被添加到暂存区时，如何在不删除此文件的前提下 将其移出暂存区？ 如果文件在暂存后被删除，可以使用git checkout \u0026ndash; print.c恢复。如果文件在删除前执行了git commit，在删除后执行了git add指令，可以使用git reset HEAD恢复到上一次commit时的状态，之后再使用git checkout \u0026ndash; print.c恢复文件。 先使用git restore \u0026ndash;staged print.c取消暂存，再使用git restore print.c放弃工作区的修改。 git rm \u0026ndash;cached hello.txt Thinking 0.4 思考下列有关 Git 的问题：\n找到在 /home/22xxxxxx/learnGit 下刚刚创建的 README.txt 文件，若不存 在则新建该文件。 在文件里加入 Testing 1，git add，git commit，提交说明记为 1。 模仿上述做法，把 1 分别改为 2 和 3，再提交两次。 使用 git log 命令查看提交日志，看是否已经有三次提交，记下提交说明为 3 的哈希值a。 进行版本回退。执行命令 git reset \u0026ndash;hard HEAD^ 后，再执行 git log，观察其变化。 找到提交说明为 1 的哈希值，执行命令 git reset \u0026ndash;hard \u0026lt;hash\u0026gt;后，再执 行 git log，观察其变化。 现在已经回到了旧版本，为了再次回到新版本，执行 git reset \u0026ndash;hard \u0026lt;hash\u0026gt;，再执行 git log，观察其变化。 有三次提交 HEAD指向说明为2的提交，并且不显示说明为3的提交 HEAD指向说明为1的提交，并且不显示说明为2, 3的提交 HEAD指向说明为3的提交 Thinking 0.5 执行如下命令, 并查看结果\necho first echo second \u0026gt; output.txt echo third \u0026gt; output.txt echo forth \u0026raquo; output.txt 在终端显示\u0026quot;first\u0026quot; 创建了一个output.txt文件，内容为\u0026quot;second\u0026quot; output.txt内容变为\u0026quot;third\u0026quot; output.txt追加内容\u0026quot;forth\u0026quot; Thinking 0.6 使用你知道的方法（包括重定向）创建下图内容的文件（文件命名为 test）， 将创建该文件的命令序列保存在 command 文件中，并将 test 文件作为批处理文件运行，将 运行结果输出至 result 文件中。给出 command 文件和 result 文件的内容，并对最后的结果进行解释说明（可以从 test 文件的内容入手）. 具体实现的过程中思考下列问题: echo echo Shell Start 与 echo `echo Shell Start` 效果是否有区别; echo echo $c\u0026gt;file1 与 echo `echo $c\u0026gt;file1` \u0026lsquo;效果是否有区别.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #!/bin/bash echo \u0026#39;echo Shell Start...\u0026#39; \u0026gt; test echo \u0026#39;echo set a = 1\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;a=1\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo set b = 2\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;b=2\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo set c = a+b\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;c=$[$a+$b]\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo c = $c\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo save c to ./file1\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo $c\u0026gt;file1\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo save b to ./file2\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo $b\u0026gt;file2\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo save a to ./file3\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo $a\u0026gt;file3\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo save file file2 file3 to file4\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;cat file1\u0026gt;file4\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;cat file2\u0026gt;\u0026gt;file4\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;cat file3\u0026gt;\u0026gt;file4\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo save file4 to ./result\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;cat file4\u0026gt;\u0026gt;result\u0026#39; \u0026gt;\u0026gt; test 1 2 3 3 2 1 结果分析：\ntest先将a和b分别赋值为1和2 令c等于a+b 将c，b，a的值分别写入file1、file2、file3，三个文件中的值分别为3, 2, 1 cat将这三个文件的值追加到file4，再把file4中的内容写入result。 result中的值为3, 2, 1。 echo echo Shell Start 与 echo ‘echo Shell Start’ 效果没有区别； echo echo $c\u0026gt;file1 与 echo ‘echo $c\u0026gt;file1’ 效果有区别，前者会将\u0026quot;echo $c\u0026quot;重定向到file1，而后者则会在终端显示\u0026quot;echo $c\u0026gt;file\u0026quot;。\n实验难点 Git的使用 工作区、暂存区、版本库、HEAD的理解 工作区（Working Directory），电脑上的一个目录即为工作区。\n版本库（Repository），使用git init指令，目录下会生成一个.git目录，这个.git目录就是git的版本库（.git不属于工作区），git版本库里有暂存区和一个指向当前分支的HEAD指针。\n暂存区（stage/index），使用git add可以把修改后的文件添加到暂存区，以便于一次性提交多个修改。\nHEAD，HEAD指向的是当前分支（master/main\u0026hellip;），也可以指向某一个commit（分离状态）。\n分离状态，有时候我们只是想在之前的某一次commit上做一些调试而不想提交到版本库，我们就可以git checkout \u0026lt;hash\u0026gt;切换到某一个commit进入HEAD分离状态，在进行一些修改并提交后，如果此时再切换到原有分支则会丢弃之前做的所有实验性修改，如果想保留修改，则可使用git checkout -b \u0026lt;new branch name\u0026gt;新建一个分支保存修改。 You are in \u0026lsquo;detached HEAD\u0026rsquo; state. You can look around, make experimental\nchanges and commit them, and you can discard any commits you make in this\nstate without impacting any branches by switching back to a branch.\nIf you want to create a new branch to retain commits you create, you may\ndo so (now or later) by using -c with the switch command. Example:\ngit switch -c Or undo this operation with:\ngit switch -\nTurn off this advice by setting config variable advice.detachedHead to false\n版本回退 git reset [\u0026ndash;hard] [\u0026ndash;soft] [\u0026ndash;mixed]，同时移动当前分支指针和HEAD指针，--hard会回退到上个版本的已提交状态，而--soft会回退到上个版本的未提交状态，--mixed会回退到上个版本已添加但未提交的状态。 git checkout \u0026lt;hash\u0026gt;，仅移动HEAD指针，不一定分支指针（HEAD分离状态）。 git checkout \u0026ndash; \u0026lt;file\u0026gt;，将暂存区的指定文件取出，强制替换工作区的文件。 git restore \u0026lt;file\u0026gt;，功能和git checkout相同。 git rm \u0026ndash;cached \u0026lt;file\u0026gt;，从暂存区中删去不想跟踪的文件。 冲突解决 当两个分支对同一行进行了修改，在合并时会出现冲突，git无法帮我们完成合并，需要手动解决冲突。\ngit merge，无破坏性，两个分支的提交均会被保存，但时间线会变复杂。 git rebase，重写原始分支的提交历史，将当前修改融合到原始分支中，原始分支的hash会变，时间线更干净但是损失了很多信息，可回溯性差。 Makefile 本质上target和dependencies都是文件，如果target已经存在，且创建时间晚于所有dependencies，则make不会执行命令。 如果一个规则的命令没有创建target文件，我们希望每次执行make \u0026lt;target\u0026gt;都会执行这个规则的命令，但是如果我们手动创建了一个target文件，则命令不会被执行，这是我们可以把这个target声明为伪目标，例如.PHONY: clean Shell脚本 转义 单引号保留字符的字面含义，单引号内不能再使用单引号，即使使用了反斜线转义也不允许。 双引号内美元符号$ ，反引号`` ，反斜杠`仍然有特殊含义 括号 [] 逻辑运算 (()) 用于算术表达式，也可在其中进行变量赋值 ${} 取变量的值 $[] 和 $(()) 数值计算并返回值 $() 运行括号中的命令并将输出替换到原处 Sed (Stream editor) 1 sed [选项] \u0026#39;命令\u0026#39; 输入文本 sed命令本身是可以解释语法的，即传入一个字符串作为命令，sed可以解析这个字符串，而我们如果要在命令中使用变量直接输入‘$1,$p’是无法被正确解析的，因为在sed命令看来$1就是一个普通字符串，我们应该把$1交给shell去解析。很简单，只需要$1放在单引号外面即可。\n于是，关于sed如何和shell交互的问题可以得出一套结论：\n遇到需要被shell解析的都不加引号，或者加双引号； 遇到shell和所执行命令共有的特殊字符时，要想被sed解析，必须加单引号，或者在双引号在加反斜线转义； 1 2 3 4 5 6 7 ➜ learnSed cat tail.sh #!/bin/bash sed -n $1\u0026#39;,$p\u0026#39; $2 ➜ learnSed bash tail.sh 4 test line4 line5 line6 实验体会 git的基本操作很简单，但是在实际多人合作中，版本回退、冲突处理等问题层出不穷，没有深入的理解很难提高效率。 刚开始接触linux和CLI，只会一些基础命令，对shell脚本的理解不深，导致上机测试手忙脚乱，不能很快定位错误。 指导书中的命令只是冰山一角，要熟练使用shell仍需要花大量的时间去自学。 参考资料 在开发过程中使用 git rebase 还是 git merge，优缺点分别是什么？https://www.zhihu.com/question/36509119/answer/2423381574\n廖雪峰的Makefile教程 https://liaoxuefeng.com/books/makefile/introduction/index.html\nsed中的疑难杂症 https://zhuanlan.zhihu.com/p/691207825\n","date":"2025-03-13T22:58:00Z","image":"https://lhy0424.top/p/os-lab0/cover_hu_4f5dec1ae3da3394.jpg","permalink":"https://lhy0424.top/p/os-lab0/","title":"BUAA-OS-lab0 实验报告"},{"content":"Transformer Transformer 最早在2017年的《Attention Is All You Need》论文中提出，通过引入 自注意力（Self-Attention）+ 位置编码（Positional Encoding）+ 多头注意力（Multi-Head Attention）+ 前馈网络（Feed-Forward Network），解决了传统 Seq2Seq 模型在处理可变长序列时的长距离依赖、计算效率等关键问题。\nseq2seq，序列到序列，输入为一段序列，输出也是一段序列，如翻译任务。\n处理可变长序列，指的是在自然语言处理（NLP）等任务中，模型需要能够应对不同长度的输入或输出序列，而不是固定长度的数据。\nwith transformer you can\nvoice-to-text text-to-voice text-to-image\u0026hellip; 《Attention is All You Need》专注于把一种语言翻译成另一种，这也是Transformer最初的设计目的，而后来被广泛应用于各种自然语言处理（NLP）任务，比如ChatGPT、DeepSeek等大模型，本文主要介绍最基础的transformer结构。\nA High-Level Look $$\rTransfomer(我是一个学生) = I\\space am\\space a\\space studuent\r$$\nToken Embedding 词嵌入 Can you can a can like a canner can a can.\ntoken? 单词片段或标点符号 将每个token转化为对应的高维向量，构成Embedding matrix Embedding matrix随机初始化，并通过数据进行学习 GPT-3中每个token的向量有12288个维度 向量的方向代表语义，语义相似的token有着相似的方向 两个词的差异也会体现在向量之差，例如man和woman的向量之差与uncle和aunt的向量之差相似，也可以理解为$\\vec{uncle}+(\\vec{woman}-\\vec{man}) = \\vec{aunt}$ 得到的词向量无上下文语义，但是其性质决定其可以用于分析上下文 Attention的目标就是让单个token通过上下文获得更丰富的语义。（比如判断出每个can的含义） 上下文长度指的即是模型每次能处理的向量数目（预测下一个token时结合的文本量） Unembedding matrix 解嵌入矩阵，可以将一个向量解析为对应的单词 Positional encoding 引入额外的位置编码刻画数据在时序上的特征 $$\rPE_{pos,2i}=sin(pos/10000^{2i/d_{model}})\\\\\rPE_{pos,2i+1}=cos(pos/10000^{2i/d_{model}})\r$$\nEncoder self-attention自注意力机制 Feed Forward Neural Network 前馈神经网络 Self-Attention 自注意力机制 “ Can you can a can like a canner can a can. ”\ncan 代指的是什么？需要联系上下文 Q、K、V **如何理解矩阵形式的Q、K、V：**在map/dict查询时我们可以根据key查询数据，如果query=key，那么取出key对应的数据。但是对于矩阵形式的Q、K、V，这样并不可行，只能变得soft一些，计算query和key的关系之后再对value加权求和。（softmax也是类似的思想）\n$Query\\space vector = \\vec{E} \\times W_Q$\n$ Key\\space vector=\\vec{E}\\times W_K$\n$Value\\space vector = \\vec{E}\\times W_V$\nValue反映了如果要改变目标词的语义，需要对目标词的embedding加上一个什么样的向量 $W_K\\space W_K\\space W_V$均通过训练获得\n$$\rSoftmax(\\frac{q_i\\cdot k_j}{\\sqrt{d_k}})\\\\ d_k\\space is\\space the \\space dimension\\space of\\space the\\space key\\space vector\r$$这个公式表示在j位置的token在i位置的表达量，显然i位置本身的token在i位置表达量最大。\nquery点乘key得到一个较大的正数，即称key代表的embedding注意到了query代表的embedding 如果是一个较小值或负值，则代表两个词互不相关 $$\rz_i = \\sum_{j=1}^{n} softmax(\\frac{q_i\\cdot k_j}{\\sqrt{d_k}}) \\times v_j \\\\or\\\\\rAttention(Q,K,V) = softmax(\\frac{QK^T}{\\sqrt{d_k}})V\r$$ 之后我们用softmax score乘每个位置上的value向量再求和，即可得到该位置上的self-attention层的输出向量$z_1$，$z_1$之后会传入feed-forward neural network。\nMulti-head attention 多头注意力机制 模型在对当前位置的信息进行编码时，会过度的将注意力集中于自身的位置\nMulti-head attention allows the model to jointly attend to information from different representation subspaces at different positions.\n提高模型对其他位置的注意力。之前的方法得到的z向量尽管以及包含了其他位置的编码信息，但是其仍主要受自身的影响。\nTransformer有8个注意力头，即每个encoder/decoder有八组QKV\n每组QKV分别按上述方法进行计算得到一组z向量，再将他们拼接起来叉乘一个新的矩阵$W^o$，得到一个新的z向量\nInside the Multilayer Perception 多层感知器 推理需要事实作为依据，大模型是如何存储事实的？\nLinear (up projection) 乘一个矩阵$W_{\\uparrow}$，将向量映射到高维空间\n矩阵的每一行都是一个问题 (简化理解)\n$\\vec{B_{\\uparrow}}$为Bias偏置，确保当embedding与问题相符时为1，其他情况为0或负\n$$\rW_{\\uparrow}\\vec{E}+\\vec{B_{\\uparrow}}\r$$\nReLU线性整流函数 对得到的高维向量进行处理：非线性函数，将负值映射为0，正值不变 Linear (down projection) 对高维向量进行降维处理，使输出向量的维数降回到嵌入空间的维数 $$\rW_{\\downarrow}(\\space ReLU(W_{\\uparrow}\\vec{E}+B_{\\uparrow})\\space) + B_{\\downarrow}\r$$\nResiduals 残差 在每个子层（如自注意力层和前馈神经网络层）中，残差连接允许输入信号绕过子层，直接与子层的输出相加。这意味着输出是子层的原始输入与子层的变换输出的和。\n用于帮助解决深度神经网络训练过程中的梯度消失或梯度爆炸问题。\n梯度消失：梯度趋近于零，网络权重无法更新或更新的很微小，网络训练再久也不会有效果； 梯度爆炸：梯度呈指数级增长，变的非常大，然后导致网络权重的大幅更新，使网络变得不稳定。 $$\routput=x+F(x)\\space(其中 F(x)F(x)F(x) 表示子层的复杂变换)\r$$即使 F(x)F(x)F(x) 部分可能会导致数值不稳定，恒等项 xxx 总能为梯度提供一个稳定的基础，从而改善整体训练的稳定性。\nDecoder 解码器也含有这两个层，但是中间增加了一个注意力层帮助解码器关注到相关的输入 解码器的self-attention与编码器稍有不同，其只关注输出序列中位于当前位置之前的token（masking掩码） 掩码：在计算 $q_i\\cdot k_j$ 时将将 $j\u0026gt;i$ 的项置为$-\\infin$，在softmax的过程中$-\\infin$会被转化为0，起到屏蔽作用 Linear Layer 实际上，decoder的输出是一个浮点型的向量，如何得到一个token？\n线性层是一个全链接神经网络，将decoder的输出向量转化为一个更大的向量（logits vector） logits vector的维度等于“output vocabulary”所包含的token数（模型在训练中学习到的的token），logits vector中的每一格就是对某个token的评分 之后softmax layer会将logits vector转化为概率（归一化，所有数值相加等于一），选取概率最大的token softmax with temperature softmax对向量进行归一化，确保$\\sum x_n = 1$ $$\r\\begin{bmatrix}\rx_1\\\\\rx_2\\\\\rx_3\\\\\r...\r\\end{bmatrix}\r\\rightarrow\r\\begin{bmatrix}\r\\frac{e^{x_1/T}}{\\sum_{n=0}^{N-1}e^{x_n/T}}\\\\\r\\frac{e^{x_2/T}}{\\sum_{n=0}^{N-1}e^{x_n/T}}\\\\\r\\frac{e^{x_3/T}}{\\sum_{n=0}^{N-1}e^{x_n/T}}\\\\\r...\r\\end{bmatrix}\r$$ T越大，会给小数值赋予更多的权重，分布越均匀 模型更愿意选择可能性较低的词 T越小，较大的数组优势会更明显。 T = 0时模型总是会选择最可能的词 参考资料 《Attention Is All You Need》 https://arxiv.org/abs/1706.03762 https://jalammar.github.io/illustrated-transformer/ https://www.3blue1brown.com/topics/neural-networks ","date":"2025-03-10T15:32:00Z","image":"https://lhy0424.top/p/transformer/transformers_2b9aba81a7_hu_c1faf802ba54c4e7.jpg","permalink":"https://lhy0424.top/p/transformer/","title":"Tansformer学习笔记"},{"content":"P7_MIPS微系统 预备知识 异常程序处理 先要明白一点，Mars不会帮你处理中断异常，Mars遇到异常指令或中断信号会跳至中断异常处理程序（0x4180之后），如何处理中断异常完全由0x4180之后的代码决定。\n先看课程组给出的示例程序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 # 程序首先从这里运行 .text # 只允许外部中断 ori $t0, $0, 0x1001 mtc0 $t0, $12 # 算术溢出 lui $t0, 0x7fff lui $t1, 0x7fff add $t2, $t0, $t1 end: beq $0, $0, end nop .ktext 0x4180 _entry: # 保存上下文 j _save_context nop _main_handler: # 取出 ExcCode mfc0 $k0, $13 ori $k1, $0, 0x7c and $k0, $k0, $k1 # 如果是中断，直接恢复上下文 beq $k0, $0, _restore_context nop # 将 EPC + 4，即处理异常的方法就是跳过当前指令 mfc0 $k0, $14 addu $k0, $k0, 4 mtc0 $k0, $14 j _restore_context nop _exception_return: eret _save_context: ori $k0, $0, 0x1000 # 在栈上找一块空间保存现场 addiu $k0, $k0, -256 sw $sp, 116($k0) # 最先保存栈指针 move $sp, $k0 # 依次保存通用寄存器（注意要跳过 $sp）、HI 和 LO sw $1, 4($sp) sw $2, 8($sp) # ...... sw $31, 124($sp) mfhi $k0 mflo $k1 sw $k0, 128($sp) sw $k1, 132($sp) j _main_handler nop _restore_context: # 依次恢复通用寄存器（注意要跳过 $sp）、 HI 和 LO lw $1, 4($sp) lw $2, 8($sp) # ...... lw $31, 124($sp) lw $k0, 128($sp) lw $k1, 132($sp) mthi $k0 mtlo $k1 # 最后恢复栈指针 lw $sp, 116($sp) j _exception_return nop 代码解释 .text: Subsequent items (instructions) stored in Text segment at next available address.随后的条目（指令）存储在文本段的下一个可用地址中。普通的用户模式下的代码段，简单来说就是存指令的地方。\n.ktext: Subsequent items stored in Kernel Text segment at next available address.随后的条目存储在内核文本段的下一个可用地址中。即内核模式下的代码段，内核模式下运行，具有最高权限，可以直接访问硬件和受保护的资源。对于p7来说就是存放异常处理程序的地方。\n异常包括很多种类型，中断和异常也不同，不同的异常或中断处理方式不一样，因此我们需要记录下异常或中断的信息，然后用特定方式处理异常，这就是CP0（协处理器）的作用。\n进入中断异常处理程序后，我们先从CP0中获取异常或中断信息，然后跳转至不同的地方处理异常中断，一般最后都会跳转到eret，返回主程序。\nCPU与外设的交互 CPU的作用就是对外界输入数据做出对应的处理后返回结果。\n外设 对于p7，我们有三个外设需要处理。这三个外设的作用就是时不时向cpu发出一个中断信号。\n计时器（Timer）：计算机系统中的计时部件，可以按照配置定时地产生时钟中断。 存储器（Memory）：计算机系统中的存储部件，用于存储指令和数据。我们在 P6 的时候已经接触过了。 中断发生器（InterruptGenerator）：抽象的计算机系统外设，会随机的产生外部中断信号，产生的中断信号在 CPU 响应前会持续置高。 内存 我们可以认为内存也是一种外设。\n我们可以认为指令、数据、异常处理程序、外设寄存器等都是储存在同一内存中，只不过存储的位置不同，有着严格的界限。\n条目 地址或地址范围 备注 数据存储器 0x0000_0000∼0x0000_2FFF 指令存储器 0x0000_3000∼0x0000_6FFF PC 初始值 0x0000_3000 异常处理程序入口地址 0x0000_4180 计时器 0 寄存器地址 0x0000_7F00∼0x0000_7F0B 计时器 0 的 3 个寄存器 计时器 1 寄存器地址 0x0000_7F10∼0x0000_7F1B 计时器 1 的 3 个寄存器 中断发生器响应地址 0x0000_7F20∼0x0000_7F23 宏观PC 对于流水线寄存器，每一流水级的PC都不同。我们希望CPU实现的功能应该是单周期的，引入多周期只是为了提高效率。如果我们把CPU封装起来，不关注内部的复杂过程，在外部看来CPU应该只有一个PC，即CPU一个周期仅执行一条指令。为此我们需要引入宏观PC的概念。\n我们将 CP0 放在 M 级（大家都放在M级，方便对拍），因此也以 M 级为界线，规定 M 级的 PC 就是宏观 PC。 **所谓“宏观”指令，表示该指令之前的所有指令序列对 CPU 的更新已完成，该指令及其之后的指令序列对 CPU 的更新未完成。**放在M级显然满足这个定义。 Tasks Task-1: 建立与外界的联系 Timer Timer内部有三个寄存器: 0号寄存器ctrl、1号寄存器preset、2号寄存器count。虽然说是寄存器，但我们可以认为其实内存的一部分。 0号寄存器ctrl 1号寄存器preset 2号寄存器count TC1 0x0000_7F00∼0x0000_7F03 0x0000_7F04∼0x0000_7F07 0x0000_7F08∼0x0000_7F0b TC2 0x0000_7F10∼0x0000_7F13 0x0000_7F14∼0x0000_7F17 0x0000_7F18∼0x0000_7F1b 我们可以通过sw指令向对应Timer寄存器中存值以开启计时并调整倒计时。\n1 2 3 4 5 6 7 8 9 10 11 # MODE 0 for timer1 ori $t1 $0 9 #设置计时使能和中断屏蔽 sw $t1 0x7F00($0) ori $t1 $0 1 #设置计时数 sw $t1 0x7F04($0) # MODE 1 for timer1 ori $t1 $0 11 #设置计时使能和中断屏蔽 sw $t1 0x7F00($0) ori $t1 $0 10 #设置计时数 sw $t1 0x7F04($0) Task-2: 记录异常并流水 where CP0: M级。 延迟槽指令: 如果一个处于延迟槽的指令发生了异常，我们从异常处理程序中返回时需要回到它的上一个指令（跳转指令）。因此我们需要增加判断一个信号用于判断指令是否在延迟槽中，并向后流水传至CP0。（branch、jump、jal、jr在ID级，IF级的指令即处于延迟槽中）。 1 2 assign BD_IF = ((branch_ID === 1\u0026#39;b1) || (jump_ID === 1\u0026#39;b1))? 1\u0026#39;b1: 1\u0026#39;b0; 内部异常和外部中断：同时发生时处理外部中断，当内部无异常时设为Int(外部中断)。 一条指令多个异常 \u0026amp; 多个指令异常：优先处理最早可以探查到的异常。 异常与中断码 助记符与名称 指令与指令类型 描述 0 Int （外部中断） 所有指令 中断请求，来源于计时器与外部中断。 4 AdEL （取指异常） 所有指令 PC 地址未字对齐。 1 4 AdEL （取指异常） 所有指令 PC 地址超过 0x3000 ~ 0x6ffc。 1 4 AdEL （取数异常） lw 取数地址未与 4 字节对齐。 1 4 AdEL （取数异常） lh 取数地址未与 2 字节对齐。 1 4 AdEL （取数异常） lh, lb 取 Timer 寄存器的值。 4 AdEL （取数异常） load 型指令 计算地址时加法溢出。 1 4 AdEL （取数异常） load 型指令 取数地址超出 DM、Timer0、Timer1、中断发生器的范围。 5 AdES （存数异常） sw 存数地址未 4 字节对齐。 1 5 AdES （存数异常） sh 存数地址未 2 字节对齐。 1 5 AdES （存数异常） sh, sb 存 Timer 寄存器的值。 5 AdES （存数异常） store 型指令 计算地址加法溢出。 1 5 AdES （存数异常） store 型指令 向计时器的 Count 寄存器存值。 5 AdES （存数异常） store 型指令 存数地址超出 DM、Timer0、Timer1、中断发生器的范围。 8 Syscall （系统调用） syscall 系统调用。 10 RI（未知指令） - 未知的指令码。 12 Ov（溢出异常） add, addi, sub 算术溢出。 1 IF级 PC 地址未字对齐 AdEL PC 地址超过 0x3000 ~ 0x6ffc AdEL 1 2 3 // in PC module assign exc = ((pc \u0026lt; 32\u0026#39;h3000) || (pc \u0026gt; 32\u0026#39;h6ffc))? 4\u0026#39;d4: (pc[1:0] != 2\u0026#39;b0)? 4\u0026#39;d4: 4\u0026#39;d0; ID级 未知的指令码 RI syscall 对于syscall指令我们只需发出一个异常信号即可 syscall 如果有if嵌套，注意内部if对应的else也需要判断为未知指令。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // in controller module if (OpCode == xxxxxx) begin if (Funct == xxxxxx) begin //ctrl signal assignment end else begin //exception RI exc = 4\u0026#39;d10; end end else if (OpCode == xxxxxx) begin //ctrl signal assignment end else begin //exception RI exc = 4\u0026#39;d10; end EX级 算术溢出 OV 1 2 3 4 5 6 7 8 9 10 11 12 13 wire [32:0] A_ext = {A[31],A}; wire [32:0] B_ext = {B[31],B}; wire [32:0] addi_temp = A_ext + B_ext; wire addi_overflow = ((F == `ADDI) \u0026amp;\u0026amp; (addi_temp[32] != addi_temp[31])); wire [32:0] add_temp = A_ext + B_ext; wire add_overflow = ((F == `ADD) \u0026amp;\u0026amp; (add_temp[32] != add_temp[31])); wire [32:0] sub_temp = A_ext - B_ext; wire sub_overflow = ((F == `SUB) \u0026amp;\u0026amp; (sub_temp[32] != sub_temp[31])); assign exc = (addi_overflow | add_overflow | sub_overflow)? 4\u0026#39;d12: 4\u0026#39;d0; MA级 load类指令 lw取数地址未与 4 字节对齐 AdEL lh、lb取数地址未与 2 字节对齐 AdEL lh、lb取 Timer 寄存器的值：寄存器的值为32位，取半字或比特是非法行为非法 AdEL 计算地址时加法溢出 AdEL 取数地址超出 DM、Timer0、Timer1、中断发生器的范围 AdEL store类指令 sw存数地址未 4 字节对齐 AdES sh、sb存数地址未 2 字节对齐 AdES sh、sb存 Timer 寄存器的值 ：寄存器的值为32位，存半字或比特是非法行为非法 AdES 计算地址加法溢出 AdES 向计时器的 Count 寄存器存值 ：计时器的count寄存器是只读寄存器(read-only) AdES 存数地址超出 DM、Timer0、Timer1、中断发生器的范围 AdES 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 //load EXC wire exc_load_align = (((load_type_MA == 3\u0026#39;b111) \u0026amp;\u0026amp; (byte_offset != 2\u0026#39;b00)) || //lw ((load_type_MA == 3\u0026#39;b100) \u0026amp;\u0026amp; (byte_offset[0] != 1\u0026#39;b0))); //lh wire exc_load_adov = (load_type_MA \u0026amp;\u0026amp; (EX_EXCCode_pip_MA == 4\u0026#39;d12)); wire exc_load_OutOfRange = !(((ALU_C_MA \u0026gt;= 32\u0026#39;h0) \u0026amp;\u0026amp; (ALU_C_MA \u0026lt;= 32\u0026#39;h2fff)) || //DM ((ALU_C_MA \u0026gt;= 32\u0026#39;h7f00) \u0026amp;\u0026amp; (ALU_C_MA \u0026lt;= 32\u0026#39;h7f0b)) || //TC0 ((ALU_C_MA \u0026gt;= 32\u0026#39;h7f10) \u0026amp;\u0026amp; (ALU_C_MA \u0026lt;= 32\u0026#39;h7f1b))); //TC1 wire exc_load_timer = ((load_type_MA == 3\u0026#39;b100 || load_type_MA == 3\u0026#39;b010) \u0026amp;\u0026amp; ALU_C_MA \u0026gt;= 32\u0026#39;h7f00); wire EXCCode_ADEL = (load_type_MA) \u0026amp;\u0026amp; (exc_load_align || exc_load_adov || exc_load_OutOfRange || exc_load_timer); //store EXC wire exc_store_align = (((store_type_MA == 3\u0026#39;b001) \u0026amp;\u0026amp; (byte_offset != 2\u0026#39;b00)) || ((store_type_MA == 3\u0026#39;b100) \u0026amp;\u0026amp; (byte_offset[0] != 1\u0026#39;b0))); wire exc_store_adov = (store_type_MA \u0026amp;\u0026amp; (EX_EXCCode_pip_MA == 4\u0026#39;d12)); //addr overflow wire exc_store_OutOfRange = !(((ALU_C_MA \u0026gt;= 32\u0026#39;h0) \u0026amp;\u0026amp; (ALU_C_MA \u0026lt;= 32\u0026#39;h2fff)) || //DM ((ALU_C_MA \u0026gt;= 32\u0026#39;h7f00) \u0026amp;\u0026amp; (ALU_C_MA \u0026lt;= 32\u0026#39;h7f0b)) || //TC0 ((ALU_C_MA \u0026gt;= 32\u0026#39;h7f10) \u0026amp;\u0026amp; (ALU_C_MA \u0026lt;= 32\u0026#39;h7f1b))); //TC1 wire exc_store_timer = (store_type_MA \u0026amp;\u0026amp; ALU_C_MA \u0026gt;= 32\u0026#39;h0000_7f08 \u0026amp;\u0026amp; ALU_C_MA \u0026lt;= 32\u0026#39;h0000_7f0b) || (store_type_MA \u0026amp;\u0026amp; ALU_C_MA \u0026gt;= 32\u0026#39;h0000_7f18 \u0026amp;\u0026amp; ALU_C_MA \u0026lt;= 32\u0026#39;h0000_7f1b) || ((store_type_MA == 3\u0026#39;b010 || store_type_MA == 3\u0026#39;b100) \u0026amp;\u0026amp; ALU_C_MA \u0026gt;= 32\u0026#39;h7f00); wire EXCCode_ADES = (store_type_MA) \u0026amp;\u0026amp; (exc_store_align || exc_store_adov || exc_store_OutOfRange || exc_store_timer); assign MA_EXCCode_pip_MA = EXCCode_ADEL? 4\u0026#39;d4: EXCCode_ADES? 4\u0026#39;d5: 4\u0026#39;d0; Task-3: 加入协处理器CP0 所有寄存器均为32bits 处理中断和异常信号，判断是否发出req信号，发出req信号时所有流水寄存器清空（部分信号需要特殊处理） eret指令需要清空EXL部分 0001_0000 寄存器 寄存器编号 功能域 位域 解释 SR（State Register） 12 IM（Interrupt Mask） 15:8 分别对应六个外部中断，相应位置 1 表示允许中断，置 0 表示禁止中断。这是一个被动的功能，只能通过 mtc0 这个指令修改，通过修改这个功能域，我们可以屏蔽一些中断。 SR（State Register） 12 EXL（Exception Level） 1 任何异常发生时置位，这会强制进入核心态（也就是进入异常处理程序）并禁止中断。 SR（State Register） 12 IE（Interrupt Enable） 0 全局中断使能，该位置 1 表示允许中断，置 0 表示禁止中断。 Cause 13 BD（Branch Delay） 31 当该位置 1 的时候，EPC 指向当前指令的前一条指令（一定为跳转），否则指向当前指令。 Cause 13 IP（Interrupt Pending） 15:10 为 6 位待决的中断位，分别对应 6 个外部中断，相应位置 1 表示有中断，置 0 表示无中断，将会每个周期被修改一次，修改的内容来自计时器和外部中断。 Cause 13 ExcCode 6:2 异常编码，记录当前发生的是什么异常。 EPC 14 - - 记录异常处理结束后需要返回的 PC。 端口 方向 位数 解释 clk IN 1 时钟信号。 reset IN 1 复位信号。 en IN 1 写使能信号。 CP0Add IN 5 读取/写入目标寄存器地址。 CP0In IN 32 写入寄存器数据。 CP0Out OUT 32 读出寄存器数据。 VPC IN 32 当前异常中断发生时PC的值。 BDIn IN 1 当前异常中断发生指令是否是延迟槽内指令。 ExcCodeIn IN 5 当前发生异常类型。 HWInt IN 6 外部产生的中断信号。 EXLClr IN 1 是否结束异常中断处理（复位 EXL）。 EPCOut OUT 32 EPC 的值。 Req OUT 1 进入处理程序请求。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 `define IM regs[12][15:10] `define EXL regs[12][1] `define IE regs[12][0] `define BD regs[13][31] `define IP regs[13][15:10] `define EXCCode regs[13][6:2]\t// SR-12, Cause-13, EPC-14 reg [31:0] regs [0:31]; assign CP0Out = regs[CP0Addr]; wire IntReq = (|(HWInt \u0026amp; `IM)) \u0026amp; !`EXL \u0026amp; `IE; // 允许当前中断 且 不在中断异常中 且 允许中断发生 wire ExcReq = (|EXCCodeIn) \u0026amp; !`EXL; // 存在异常 且 不在中断中 assign Req = IntReq | ExcReq; wire [31:0] tempEPC = (Req) ? (BDIn ? VPC-4 : VPC) : regs[14]; assign EPCOut = {tempEPC[31:2], 2\u0026#39;b0}; integer i; initial begin for (i=0;i\u0026lt;32;i=i+1) begin regs[i] = 0; end end always @(posedge clk) begin if (reset) begin for (i=0;i\u0026lt;32;i=i+1) begin regs[i] \u0026lt;= 0; end end else begin `IP \u0026lt;= HWInt; if (en) begin regs[CP0Addr] \u0026lt;= CP0In; end if (Req) begin // int|exc `EXCCode \u0026lt;= IntReq ? 5\u0026#39;b0 : EXCCodeIn; `EXL \u0026lt;= 1\u0026#39;b1; regs[14] \u0026lt;= tempEPC; `BD \u0026lt;= BDIn; end if (EXLClr) begin `EXL \u0026lt;= 1\u0026#39;b0; end end end Task-4: 加指令 在 P6 基础上新增了 mfc0, mtc0, eret, syscall 四条新指令\n目前p7要求实现如下指令：(最好把jump指令也实现了，方便处理异常)\n1 2 3 4 5 6 nop, add, sub, and, or, slt, sltu, lui addi, andi, ori lb, lh, lw, sb, sh, sw mult, multu, div, divu, mfhi, mflo, mthi, mtlo beq, bne, jal, jr, mfc0, mtc0, eret, syscall MFC0 把CP0中的rd号寄存器的值存入grf的rt寄存器\n需要简单处理下转发，类似lw的转发 MTC0 将grf的rt号寄存器的值存入CP0的rd号寄存器\nERET 从错误处理程序中返回到主程序\n在ID级时设置next_pc为CP0的EXC 在ID级时清空延迟槽，确保后续指令不会被处理 到达MA级时，需要清空CP0的EXL部分，表示当前不在处于核心状态（异常处理程序） 在ID级时，如果EX或MA级是MTC0且目标寄存器为14号（EXC）则阻塞，确保返回地址正确。 syscall 在controller里发出一个异常信号（异常码为8）即可\n流水寄存器行为 为什么要修改寄存器的清空行为？ 我们在阻塞的时候会在EX级产生一个bubble，可以看作nop不发生任何作用，但实际上我们要把CPU封装为单周期CPU，级两条相邻的指令之间不会莫名其妙多出来一个nop指令。\n试想，如果不修改清空逻辑的情况下，ID级是一个延迟槽内的指令，正常来说它到达MA级时如果发生了异常或中断，我们的EPC是需要写入PC-4的，因为我们从异常处理程序中返回时需要返回到延迟槽指令的前一条指令（即跳转指令）。而如果延迟槽内的指令在ID级时发生了阻塞产生了一个\u0026rsquo;nop\u0026rsquo;，nop流水到MA级时发生了异常或中断我们该如何记录EPC？这个\u0026rsquo;nop\u0026rsquo;在外部看来是不应该存在的，其没有对应的PC，其对应的PC应该是延迟槽指令的PC，其也应该被标记为延迟槽内指令，这样从异常处理程序中返回时才能返回到正确的地址。\n按照从上至下的优先级依次处理\n信号 PC流水寄存器行为 BD流水寄存器行为 其他流水寄存器行为 reset 复位至 0x00003000 复位至 0 清空 req 设置为 0x00004180 设置为 0 清空 ID_EXLClr （仅对F级到D级流水寄存器起作用，且此时stall信号为0） 设置为当前周期的 EPC 的值 不发生变化 清空 flush（仅指对D级到E级流水寄存器起作用的阻塞信号） 不发生变化 不发生变化 清空 PC 1 2 3 4 5 6 7 8 9 10 always @(posedge clk) begin if (reset || req) begin pc \u0026lt;= req? 32\u0026#39;h4180: 32\u0026#39;h3000; end else begin if (en) begin pc \u0026lt;= next_pc; end end end IF_ID Reg clear_bd表示清空延迟槽，对于P7仅针对eret指令\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 always @(posedge clk) begin if (reset || clr || req || clear_bd) begin //置0操作省略 pc_add4_out \u0026lt;= (reset)? 32\u0026#39;h00003004: (req)? 32\u0026#39;h00004184: (clear_bd)? EPC: 0; BD_out \u0026lt;= (clear_bd)? BD: 0; end else begin if (en) begin //省略 end end end ID_EX Reg 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 always @(posedge clk) begin if (reset || stall || req) begin //置0操作省略 pc_add4_out \u0026lt;= (reset)? 32\u0026#39;h00003004: (req)? 32\u0026#39;h00004184: (stall)? pc_add4: 0; BD_out \u0026lt;= (stall)? BD: 0; end else begin if (en) begin //省略 end end end EX_MA Reg 1 2 3 4 5 6 7 8 9 10 11 12 always @(posedge clk) begin if (reset || clr || req) begin //置0操作省略 pc_add4_out \u0026lt;= reset? 32\u0026#39;h00003004: req? 32\u0026#39;h00004184: 0; end else begin if (en) begin //省略 end end end MA_WB Reg 1 2 3 4 5 6 7 8 9 10 11 always @(posedge clk) begin if (clr || reset || req) begin //置0操作省略 pc_add4_out \u0026lt;= reset? 32\u0026#39;h00003004: req? 32\u0026#39;h00004184: 0; end else begin if (en) begin //省略 end end 我的Bug 以下是我在通过课下弱测和中测后发现的bug：\n不涉及计算操作时ALUOP默认设为了`ADD，导致不是ALU类指令时出现了溢出情况。 当MA级异常时，如果EX级为mthi或mtlo时仍会向HI或LO中写入值。 当PC错误或遇到未知指令时没有向后传递nop。 mtc0位于MA级时，如果当出现中断时，仍会向CP0中的寄存器写入值。 EXCCode优先级问题。load或store指令会触发EX级的算术overflow（异常码12）异常，在MA级也会除法overflow（异常码4或5）的异常，按照优先处理先探查到的错误的原则我们会选择EX级的算术overflow，导致存入CP0的异常码错误。 测试方案 手动构造样例确保新指令的功能正确性，尽可能覆盖大部分异常情况。 随机生成指令强测确保转发和阻塞的正确性。对CO-Killer略加修改，生成符合要求的随机数据。 限制读写寄存器的范围，能够尽可能多的造成数据冒险，再加上大量随机数据，基本可以覆盖全部转发和阻塞情况。 利用自己写的python脚本填充nop至0x4180。 定时器产生周期性中断信号，测试timer的中断是否正确被处理。 修改testbench产生中断，测试中断发生器发出的中断是否正确被处理。 1 2 3 4 5 6 # 填充nop last_pc = input(\u0026#39;enter the last pc in text: \u0026#39;) pc = int(last_pc, 16) + 4 while pc \u0026lt; 0x4180: print(f\u0026#34;# {hex(pc)}\\nnop\u0026#34;) pc += 4 思考题 请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？ 鼠标和键盘产生中断信号，进入中断处理区的对应位置，将输入信号从鼠标和键盘中读入寄存器。\n请思考为什么我们的 CPU 处理中断异常必须是已经指定好的地址？如果你的 CPU 支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法） 指定好的中断处理入口地址由硬件设计决定，能确保所有中断和异常按照既定逻辑处理。如果允许用户自定义入口地址，用户可能会直接跳过关键的上下文保存步骤，导致程序状态紊乱 指定的中断地址通常位于受保护的系统区域，由操作系统或固件控制。用户故意定义有害的中断处理程序，例如窃取敏感信息或修改关键数据。 为何与外设通信需要 Bridge？ CPU与外设数据吞吐量存在差异：Bridge充当缓冲区和速率匹配器，协调高速的处理器与低速外设之间的数据交换。 地址映射差异：Bridge可以对地址进行解码，将处理器的访问请求转化为外设能够理解的操作。 请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并针对每一种模式绘制状态移图。 MODE 0\n定时产生中断信号\nMODE 1\n周期性产生中断信号\n倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的 CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？ 如果此时有一个中断或异常信号，则CP0记录下的PC为0x0000，在从异常处理程序返回时会发生错误。\n应该保留PC值，由于在Req信号有效时，通过将流水寄存器的PC值不进行复位，使得达到精确异常的效果。使得回到EPC时依然是精确的。\n为什么 jalr 指令为什么不能写成 jalr $31, $31？ 如果 jalr $31 $31 的延迟槽内发生异常或需要响应中断。那么 $31 寄存器的值已经被 jalr 改变，但是处理异常结束后，会再次执行 jalr 指令，这就会跳转到不正确的 PC 地址。\n[P7 选做] 请详细描述你的测试方案及测试数据构造策略。 见上文\n课程组官方TestBench 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 `timescale 1ns/1ps module mips_txt; reg clk; reg reset; reg interrupt; wire [31:0] macroscopic_pc; wire [31:0] i_inst_addr; wire [31:0] i_inst_rdata; wire [31:0] m_data_addr; wire [31:0] m_data_rdata; wire [31:0] m_data_wdata; wire [3 :0] m_data_byteen; wire [31:0] m_int_addr; wire [3 :0] m_int_byteen; wire [31:0] m_inst_addr; wire\tw_grf_we; wire [4 :0] w_grf_addr; wire [31:0] w_grf_wdata; wire [31:0] w_inst_addr; mips uut( .clk(clk), .reset(reset), .interrupt(interrupt), .macroscopic_pc(macroscopic_pc), .i_inst_addr(i_inst_addr), .i_inst_rdata(i_inst_rdata), .m_data_addr(m_data_addr), .m_data_rdata(m_data_rdata), .m_data_wdata(m_data_wdata), .m_data_byteen(m_data_byteen), .m_int_addr(m_int_addr), .m_int_byteen(m_int_byteen), .m_inst_addr(m_inst_addr), .w_grf_we(w_grf_we), .w_grf_addr(w_grf_addr), .w_grf_wdata(w_grf_wdata), .w_inst_addr(w_inst_addr) ); initial begin clk \u0026lt;= 0; reset \u0026lt;= 1; interrupt \u0026lt;= 0; #20 reset \u0026lt;= 0; end integer i; reg [31:0] fixed_addr; reg [31:0] fixed_wdata; reg [31:0] data[0:4095]; reg [31:0] inst[0:5119]; // ----------- For Instructions ----------- assign m_data_rdata = data[(m_data_addr \u0026gt;\u0026gt; 2) % 5120]; assign i_inst_rdata = inst[((i_inst_addr - 32\u0026#39;h3000) \u0026gt;\u0026gt; 2) % 5120]; initial begin $readmemh(\u0026#34;code.txt\u0026#34;, inst); for (i = 0; i \u0026lt; 5120; i = i + 1) data[i] \u0026lt;= 0; end // ----------- For Data Memory ----------- always @(*) begin fixed_wdata = data[(m_data_addr \u0026gt;\u0026gt; 2) \u0026amp; 4095]; fixed_addr = m_data_addr \u0026amp; 32\u0026#39;hfffffffc; if (m_data_byteen[3]) fixed_wdata[31:24] = m_data_wdata[31:24]; if (m_data_byteen[2]) fixed_wdata[23:16] = m_data_wdata[23:16]; if (m_data_byteen[1]) fixed_wdata[15: 8] = m_data_wdata[15: 8]; if (m_data_byteen[0]) fixed_wdata[7 : 0] = m_data_wdata[7 : 0]; end always @(posedge clk) begin if (reset) for (i = 0; i \u0026lt; 4096; i = i + 1) data[i] \u0026lt;= 0; else if (|m_data_byteen \u0026amp;\u0026amp; fixed_addr \u0026gt;\u0026gt; 2 \u0026lt; 4096) begin data[fixed_addr \u0026gt;\u0026gt; 2] \u0026lt;= fixed_wdata; $display(\u0026#34;%d@%h: *%h \u0026lt;= %h\u0026#34;, $time, m_inst_addr, fixed_addr, fixed_wdata); end end // ----------- For Registers ----------- always @(posedge clk) begin if (~reset) begin if (w_grf_we \u0026amp;\u0026amp; (w_grf_addr != 0)) begin $display(\u0026#34;%d@%h: $%d \u0026lt;= %h\u0026#34;, $time, w_inst_addr, w_grf_addr, w_grf_wdata); end end end // ----------- For Interrupt ----------- wire [31:0] fixed_macroscopic_pc; assign fixed_macroscopic_pc = macroscopic_pc \u0026amp; 32\u0026#39;hfffffffc; parameter target_pc = 32\u0026#39;h00003010; integer count; initial begin count = 0; end always @(negedge clk) begin if (reset) begin interrupt = 0; end else begin if (interrupt) begin if (|m_int_byteen \u0026amp;\u0026amp; (m_int_addr \u0026amp; 32\u0026#39;hfffffffc) == 32\u0026#39;h7f20) begin interrupt = 0; end end else if (fixed_macroscopic_pc == target_pc) begin if (count == 0) begin count = 1; interrupt = 1; end end end end always #2 clk \u0026lt;= ~clk; endmodule ","date":"2024-12-20T00:32:00Z","image":"https://lhy0424.top/p/co_p7/P7_cover_hu_3e4b1a6e84645e0b.jpg","permalink":"https://lhy0424.top/p/co_p7/","title":"P7_设计文档"},{"content":"P6_document Hazard.v input explain Instr_ID ID阶段的指令码 Instr_EX EX阶段的指令码 Instr_MA MA阶段的指令码 A3_EX EX阶段的寄存器写入地址 A3_MA MA阶段的寄存器写入地址 busy 乘除槽正在进行计算 start 乘除槽开始进行计算 T_use表格（需求者） 指令位于ID级时，还需要多少个周期才必须要使用数据。\nadd sub ori lw sw beq lui jal jr nop $T_{use}(rs)$ 1 1 1 1 1 0 1 0 $T_{use}(rt)$ 1 1 2 0 P6_new and or slt sltu addi andi lb lh sb sh $T_{use}(rs)$ 1 1 1 1 1 1 1 1 1 1 $T_{use}(rt)$ 1 1 1 1 2 2 P6_new mult multu div divu mfhi mflo mthi mtlo bne $T_{use}(rs)$ 1 1 1 1 1 1 0 $T_{use}(rt)$ 1 1 1 1 0 1 2 3 4 5 6 7 8 wire [1:0] Tuse_rs = (add_ID | sub_ID | ori_ID | lw_ID | sw_ID | lui_ID | and_ID | or_ID | slt_ID | sltu_ID | addi_ID | andi_ID | lb_ID | lh_ID | sb_ID | sh_ID | mthi_ID | mtlo_ID | mult_ID | multu_ID | div_ID | divu_ID)?2\u0026#39;b01: (beq_ID | jr_ID | bne_ID)? 2\u0026#39;b00: 2\u0026#39;b11; wire [1:0] Tuse_rt = (add_ID | sub_ID | and_ID | or_ID | slt_ID |sltu_ID | mult_ID | multu_ID | div_ID | divu_ID)? 2\u0026#39;b01: (sw_ID | sb_ID | sh_ID)? 2\u0026#39;b10: (beq_ID | bne_ID)? 2\u0026#39;b00: 2\u0026#39;b11; T_new表格（供给者） T_new: 供给指令位于某个流水级时还需要多少个周期才可以计算出结果并存储到流水寄存器中。\n早于需求指令进入流水线的供给者还需要多少cycle能够产生需求者需要的寄存器值。\nIntsr add sub ori lw sw beq lui jal jr nop 功能部件(结果来源) ALU ALU ALU DM ALU PC EX 1 1 1 2 1 0 MA 1 0 WB 0 0 P6_new_Intsr and or slt sltu addi andi lb lh sb sh 功能部件(结果来源) ALU ALU ALU ALU ALU ALU DM DM EX 1 1 1 1 1 1 2 2 MA 1 1 WB 0 0 P6_new_Intsr mult multu div divu mfhi mflo mthi mtlo bne 功能部件(结果来源) mdb mdb EX 1 1 MA WB 1 2 3 wire [1:0] Tnew_EX = (add_EX | sub_EX | ori_EX | lui_EX | and_EX | or_EX | slt_EX | sltu_EX | addi_EX | andi_EX | mfhi_EX | mflo_EX)? 2\u0026#39;b01: (lw_EX | lb_EX | lh_EX)? 2\u0026#39;b10: 2\u0026#39;b00; wire [1:0] Tnew_MA = (lw_MA | lb_MA | lh_MA)?2\u0026#39;b01:2\u0026#39;b00; rs策略矩阵 $T_{use} \\textbackslash \\space T_{new}$ EX EX EX MA MA MA WB WB WB ALU DM PC ALU DM PC ALU DM PC 1 2 0 0 1 0 0 0 0 0 S S F F S F F F F 1 F S F F F F F F F rt策略矩阵 $T_{use} \\textbackslash \\space T_{new}$ EX EX EX MA MA MA WB WB WB ALU DM PC ALU DM PC ALU DM PC 1 2 0 0 1 0 0 0 0 0 S S F F S F F F F 1 F S F F F F F F F 2 F F F F F F F F F 如何理解策略矩阵 策略矩阵针对的是AT法中的Time部分，具体判断阻塞还是转发需要综合Adress部分 对于ALU型指令，如add，只需要关注 $T_{new}$ 的ALU一列，其表示在当前流水级下，还有多少周期才能计算出结果并存入流水级寄存器。 1 2 3 4 5 6 7 wire Stall_RS_EX = (Tuse_rs \u0026lt; Tnew_EX) \u0026amp; (A3_EX == RS_ID \u0026amp; RS_ID != 0); wire Stall_RS_MA = (Tuse_rs \u0026lt; Tnew_MA) \u0026amp; (A3_MA == RS_ID \u0026amp; RS_ID != 0); wire Stall_RT_EX = (Tuse_rt \u0026lt; Tnew_EX) \u0026amp; (A3_EX == RT_ID \u0026amp; RT_ID != 0); wire Stall_RT_MA = (Tuse_rt \u0026lt; Tnew_MA) \u0026amp; (A3_MA == RT_ID \u0026amp; RT_ID != 0); wire Stall_md = ((busy | start) \u0026amp; (mult_ID | multu_ID | div_ID | divu_ID | mfhi_ID | mflo_ID | mthi_ID | mtlo_ID)); assign Stall = Stall_RS_EX | Stall_RS_MA | Stall_RT_EX | Stall_RT_MA | Stall_md; Forward in mips.v 数据的供给者 EX_MA级流水线寄存器 1 2 3 wire [31:0] forward_EX_MA = (RegWrite_MA \u0026amp;\u0026amp; (Mem2Reg_MA == 2\u0026#39;b00))? ALU_C_MA: (RegWrite_MA \u0026amp;\u0026amp; (Mem2Reg_MA == 2\u0026#39;b10))? pc_add4_MA + 32\u0026#39;d4: 32\u0026#39;h404; MA_WB级流水线寄存器 1 2 3 4 5 assign grf_WD = (Mem2Reg_WB == 2\u0026#39;b00) ? ALU_C_WB : (Mem2Reg_WB == 2\u0026#39;b01) ? dm_data_WB : (Mem2Reg_WB == 2\u0026#39;b10) ? pc_add4_WB + 32\u0026#39;d4 : 32\u0026#39;d0; wire [31:0] forward_MA_WB = RegWrite_WB? grf_WD: 32\u0026#39;h405; 数据需求者 ID级 1 2 3 4 5 6 7 wire [31:0] RD1_ID_valid = ((RS_ID == A3_MA) \u0026amp;\u0026amp; (A3_MA != 5\u0026#39;b0))? forward_EX_MA: ((RS_ID == A3_WB) \u0026amp;\u0026amp; (A3_WB != 5\u0026#39;b0))? forward_MA_WB: RD1_ID; wire [31:0] RD2_ID_valid = ((RT_ID == A3_MA) \u0026amp;\u0026amp; (A3_MA != 5\u0026#39;b0))? forward_EX_MA: ((RT_ID == A3_WB) \u0026amp;\u0026amp; (A3_WB != 5\u0026#39;b0))? forward_MA_WB: RD2_ID; EX级 1 2 3 4 5 6 7 8 9 10 11 12 13 //forward--select valid ALU_A and ALU_B wire [31:0] ALU_A_EX_valid = ((RS_EX == A3_MA) \u0026amp;\u0026amp; (A3_MA != 5\u0026#39;b0))? forward_EX_MA: ((RS_EX == A3_WB) \u0026amp;\u0026amp; (A3_WB != 5\u0026#39;b0))? forward_MA_WB: RD1_EX; wire [31:0] Grt_EX_valid = ((RT_EX == A3_MA) \u0026amp;\u0026amp; (A3_MA != 5\u0026#39;b0))? forward_EX_MA: ((RT_EX == A3_WB) \u0026amp;\u0026amp; (A3_WB != 5\u0026#39;b0))? forward_MA_WB: RD2_EX;//将目前正确的Grt值，流水到MA级供sw指令使用，也可供R-type-ALU指令使用 wire [31:0] Grt_MA_valid; wire [31:0] ALU_B_EX_valid = (ALUSrc_EX == 1\u0026#39;b0) ? Grt_EX_valid: (ALUSrc_EX == 1\u0026#39;b1) ? ext32_EX : 32\u0026#39;b0; MA级\n再一次获取转发数据，确保DM中的Grt值是正确的\n1 wire [31:0] Grt_MA_valid_valid = ((RT_MA == A3_WB) \u0026amp;\u0026amp; (A3_WB != 5\u0026#39;d0))? forward_MA_WB: Grt_MA_valid; 流水线寄存器 PC IF_ID ID_EX EX_MA MA_WB en nStall nStall true false true clr null false Stall true false RegDst ExtOp jump jumpSrc branch bOp ALUSrc ALUOP mdOp load_type store_type MemWrite Mem2Reg RegWrite 作用阶段 EX ID ID ID ID ID EX EX EX MA MA MA WB WB IF_ID ID_EX 1 1 1 1 1 1 1 1 1 EX_MA 1 1 1 1 1 MA_WB 1 1 Stall Explain ID级指令静止，EX级插入一个nop\nPC不写入新数据 IF_ID寄存器不写入新数据 ID_EX寄存器清零，即插入nop(0x00000000) Logic 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 module Stage_Reg( input clk, input reset, input en, input clr, input [31:0] data, output reg [31:0] data_out ); initial begin data_out \u0026lt;= 0; end always @(posedge clk) begin if (reset || clr) begin data_out \u0026lt;= 0; end else begin if (en) begin data_out \u0026lt;= data; end end end 信号解释 jumpSrc (2-bit) jumpSrc type 2\u0026rsquo;b00 branch 2\u0026rsquo;b01 jump 2\u0026rsquo;b10 jr 1 2 3 assign next_pc_ID = (jumpSrc_ID == 2\u0026#39;b00) ? branch_offset_ID: (jumpSrc_ID == 2\u0026#39;b01) ? jumpExt32_ID: (jumpSrc_ID == 2\u0026#39;b10) ? RD1_ID_valid: 32\u0026#39;h404; Mem2Reg (2-bit) Mem2Reg type 2‘b00 ALU 2\u0026rsquo;b01 lw 2\u0026rsquo;b10 link 1 2 3 assign grf_WD = (Mem2Reg_WB == 2\u0026#39;b00) ? ALU_C_WB : (Mem2Reg_WB == 2\u0026#39;b01) ? dm_data_WB : (Mem2Reg_WB == 2\u0026#39;b10) ? pc_add4_WB + 32\u0026#39;d4 : 32\u0026#39;d0; RegDst (2-bit) RegDst type 2\u0026rsquo;b00 无需写入寄存器的指令 2\u0026rsquo;b01 R-type，写入rd寄存器 2\u0026rsquo;b10 I-type，写入rt寄存器 2\u0026rsquo;b11 link，写入$ra ($31) 1 2 3 4 5 assign A3_EX = (RegDst_EX == 2\u0026#39;b00)? 5\u0026#39;b0: //null (RegDst_EX == 2\u0026#39;b01)? RD_EX: (RegDst_EX == 2\u0026#39;b10)? RT_EX: (RegDst_EX == 2\u0026#39;b11)? 5\u0026#39;h1f: 5\u0026#39;b00000; ALUOp (4-bit) ALUOp type 4\u0026rsquo;b0000 add 4\u0026rsquo;b0001 sub 4\u0026rsquo;b0010 or 4\u0026rsquo;b0011 lui 4\u0026rsquo;b0100 and 4\u0026rsquo;b0101 slt 4\u0026rsquo;b0110 sltu 4\u0026rsquo;b0111 addi 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 wire [32:0] A_ext = {A[31],A}; wire [32:0] B_ext = {B[31],B}; wire [32:0] temp = A_ext + B_ext; always @(*) begin case(F) `ADD: C = A + B; `ADDI:\tC = (temp[32] == temp[31])?temp[31:0]:32\u0026#39;d0; `SUB: C = A - B; `OR: C = A | B; `SL16: C = B \u0026lt;\u0026lt; 16; `AND:\tC = A \u0026amp; B; `SLT: C = ($signed(A) \u0026lt; $signed(B))? 32\u0026#39;b1: 32\u0026#39;b0; `SLTU: C = (A \u0026lt; B)? 32\u0026#39;b1: 32\u0026#39;b0; default:C = 0; endcase mdOp (4-bit) mdOp type 4\u0026rsquo;b0001 mult 4\u0026rsquo;b0010 multu 4\u0026rsquo;b0011 div 4\u0026rsquo;b0100 divu 4\u0026rsquo;b0101 mthi 4\u0026rsquo;b0110 mtlo 4\u0026rsquo;b0111 mfhi 4\u0026rsquo;b1000 mflo 1 2 3 4 5 6 7 8 9 // in MulDivBlock always @(*) begin case (op) 4\u0026#39;b0001: {prod_HI, prod_LO} = ($signed(A) * $signed(B));//mult 4\u0026#39;b0010: {prod_HI, prod_LO} = $unsigned(A) * $unsigned(B);//multu 4\u0026#39;b0011: {prod_HI, prod_LO} = {$signed(A) % $signed(B), $signed(A) / $signed(B)};//div 4\u0026#39;b0100: {prod_HI, prod_LO} = {A % B, A / B};//divu endcase end 1 2 3 wire [31:0] mdb_output = (mdOp_EX == 4\u0026#39;b0111)? mdb_HI: (mdOp_EX == 4\u0026#39;b1000)? mdb_LO: 32\u0026#39;d0; load_type (3-bit) load_type type 3\u0026rsquo;b000 lw 3\u0026rsquo;b001 lbu 3\u0026rsquo;b010 lb 3\u0026rsquo;b011 lhu 3\u0026rsquo;b100 lh 1 2 3 4 5 6 assign data_out = (load_type == 3\u0026#39;b000)? data_input: (load_type == 3\u0026#39;b001)? {24\u0026#39;b0, byte_sel}: (load_type == 3\u0026#39;b010)? {{24{byte_sel[7]}}, byte_sel}: (load_type == 3\u0026#39;b011)? {16\u0026#39;b0, hw_sel}: (load_type == 3\u0026#39;b100)? {{16{hw_sel[15]}}, hw_sel}: 32\u0026#39;b0; store_type (3-bit) store_type type 3\u0026rsquo;b001 sw 3\u0026rsquo;b010 sb 3\u0026rsquo;b100 sh 1 2 3 4 wire [3:0] byteen_MA = (store_type_MA == 3\u0026#39;b001)? 4\u0026#39;b1111: //word ((store_type_MA == 3\u0026#39;b010))? byte_sel://byte (store_type_MA == 3\u0026#39;b100)? hw_sel://half word 4\u0026#39;b0000; 测试方案 指令分类 R-type ALU型指令（Grd \u0026lt;- Grs ? Grt）——（add、sub、or、and、slt、sltu） ALU型指令（Grd \u0026lt;- Grt ？ shamt）——（sll、srl、sra） 跳转型指令（PC \u0026lt;- Grs）——（jr） I-type ALU-Imm型指令（Grt \u0026lt;- Grs ？ imm）——（ori、lui、addi、andi） Memory-Store型指令（Memory[Grs + offset] \u0026lt;- Grt）——（sw、sb、sh） Memory-load型指令（Grt \u0026lt;- Memory[Grs + offset]）——（lw、lb、lbu、lh） Branch型指令（Grs ? Grt，PC \u0026lt;- PC + 4 + offset）——（beq、bgez、bgtz、blez、bltz、bne） J-type J-link型指令 —— (jal) 无条件Jump型指令 IF级 ID级 EX级 MA级 WB级 R-ALU 读取数据（Grs、Grt） 计算数据 写入数据 R-jump 读取数据并跳转 I-imm 读取数据（Grt、imm） 计算数据 写入数据 I-store 读取数据（Grs+offset、Grt） 计算数据（地址） 写入数据 I-load 读取数据（Grs+offset、Grt） 计算数据（地址） 读取数据 写入数据 I-branch 读取数据（Grs、Grt）比较数据并跳转 J-link 扩展数据并跳转 传递跳转PC 传递跳转PC 写入pc+8 测试步骤 编写测试代码 包括所有阻塞情况 测试所有转发通路 可利用课程组提供的分析工具对代码测试强度进行评估 将ISE输出与Mars输出比对 可利用同学开发评测机进行快速比对 大量随机数据强测 代码生成来自学长博客 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 import random list_R = [\u0026#34;addu\u0026#34;, \u0026#34;subu\u0026#34;, \u0026#34;and\u0026#34;, \u0026#34;or\u0026#34;, \u0026#34;nor\u0026#34;, \u0026#34;xor\u0026#34;, \u0026#34;sltu\u0026#34;, \u0026#34;slt\u0026#34;, \u0026#34;sllv\u0026#34;, \u0026#34;srlv\u0026#34;, \u0026#34;srav\u0026#34;] list_I = [\u0026#34;andi\u0026#34;, \u0026#34;addiu\u0026#34;, \u0026#34;ori\u0026#34;, \u0026#34;xori\u0026#34;, \u0026#34;lui\u0026#34;, \u0026#34;slti\u0026#34;, \u0026#34;sltiu\u0026#34;] list_LS = [\u0026#34;lw\u0026#34;, \u0026#34;sw\u0026#34;, \u0026#34;lh\u0026#34;, \u0026#34;lhu\u0026#34;, \u0026#34;sh\u0026#34;, \u0026#34;lb\u0026#34;, \u0026#34;lbu\u0026#34;, \u0026#34;sb\u0026#34;] list_shift = [\u0026#34;sll\u0026#34;, \u0026#34;srl\u0026#34;, \u0026#34;sra\u0026#34;] list_B = [\u0026#34;bne\u0026#34;, \u0026#34;beq\u0026#34;,\u0026#34;bgtz\u0026#34;, \u0026#34;blez\u0026#34;, \u0026#34;bltz\u0026#34;, \u0026#34;bgez\u0026#34;] list_MD = [\u0026#34;mult\u0026#34;, \u0026#34;multu\u0026#34;, \u0026#34;div\u0026#34;, \u0026#34;divu\u0026#34;] list_MTMF = [\u0026#34;mfhi\u0026#34;, \u0026#34;mflo\u0026#34;, \u0026#34;mthi\u0026#34;, \u0026#34;mtlo\u0026#34;] #length是生成的指令所用到的寄存器个数 length = 8 #为了增大冒险概率，我们将寄存器的范围缩小到0~7 def R_test(file, n): for i in range(n): k = random.randint(0, 10000000) % len(list_R) rs = random.randint(0, 10000000) % length; rt = random.randint(0, 10000000) % length; rd = random.randint(0, 10000000) % length; s = \u0026#34;{} ${}, ${}, ${}\\n\u0026#34;.format(list_R[k], rd, rs, rt) file.write(s) def I_test(file, n): for i in range(n): k = random.randint(0, 10000000) % len(list_I) rs = random.randint(0, 10000000) % length rt = random.randint(0, 10000000) % length imm = random.randint(-32768, 32768) abs_imm = random.randint(0, 65536) if list_I[k] == \u0026#34;lui\u0026#34;: s = \u0026#34;{} ${},{}\\n\u0026#34;.format(list_I[k], rt, abs_imm) else: s = \u0026#34;{} ${}, ${}, {}\\n\u0026#34;.format(list_I[k], rt, rs, imm) file.write(s) def LS_test(file, n): for i in range(n): k = random.randint(0,10000000) % len(list_LS) ins = list_LS[k] num = 0 if(ins[1] == \u0026#34;w\u0026#34;): num = (random.randint(0,10000000) \u0026lt;\u0026lt; 2) % 4096 elif(ins[1] == \u0026#34;h\u0026#34;): num = (random.randint(0,10000000) \u0026lt;\u0026lt; 1) % 4096 else: num = (random.randint(0,10000000)) % 4096 rt = random.randint(0, 10000000) % length s = \u0026#34;{} ${}, {}($0)\\n\u0026#34;.format(ins, rt, num) file.write(s) def shift_test(file, n): for i in range(n): k = random.randint(0,10000000) % len(list_shift) shamt = random.randint(0, 10000000) % length rd = random.randint(0, 10000000) % length rt = random.randint(0, 10000000) % length s = \u0026#34;{} ${}, ${}, {}\\n\u0026#34;.format(list_shift[k], rd, rt, shamt) file.write(s) def MD_test(file, n): for i in range(n): k = random.randint(0,10000000) % len(list_MD) rs = random.randint(0, 10000000) % length rt = random.randint(0, 10000000) % length if(list_MD[k] == \u0026#34;mult\u0026#34; or list_MD[k] == \u0026#34;mul\u0026#34;): s = \u0026#34;{} ${}, ${}\\n\u0026#34;.format(list_MD[k], rs, rt) else: s = \u0026#34;{} ${}, ${}\\n\u0026#34;.format(list_MD[k], rs, 8) file.write(s) def MTMF_test(file, n): for i in range(n): k = random.randint(0,10000000) % len(list_MTMF) rs = random.randint(0, 10000000) % length s = \u0026#34;{} ${}\\n\u0026#34;.format(list_MTMF[k], rs) file.write(s) def B_test(file, lable): k = random.randint(0,10000000) % len(list_B) if(k == 0 or k == 1): rs = random.randint(0, 10000000) % length rt = random.randint(0, 10000000) % length s = \u0026#34;{} ${}, ${}, {}\\n\u0026#34;.format(list_B[k], rs, rt, lable) file.write(s) else: rs = random.randint(0, 10000000) % length s = \u0026#34;{} ${}, {}\\n\u0026#34;.format(list_B[k], rs, str(lable)) file.write(s) def b_begin(file, n): file.write(\u0026#34;\\nb_test_{}_one:\\n\u0026#34;.format(n)) B_test(file, \u0026#34;b_test_{}_one_then\u0026#34;.format(n)) R_test(file,1) file.write(\u0026#34;b_test_{}_two:\\n\u0026#34;.format(n)) B_test(file, \u0026#34;b_test_{}_two_then\u0026#34;.format(n)) I_test(file,1) file.write(\u0026#34;jal_test_{}:\\n\u0026#34;.format(n)) file.write(\u0026#34;jal jal_test_{}_then\\n\u0026#34;.format(n)) I_test(file,1) file.write(\u0026#34;end_{}:\\n\\n\u0026#34;.format(n)) R_test(file, 1) I_test(file, 1) LS_test(file, 1) shift_test(file, 1) def b_end(file, n): file.write(\u0026#34;\\nb_test_{}_one_then:\\n\u0026#34;.format(n)) R_test(file, 1) I_test(file, 1) LS_test(file, 1) shift_test(file, 1) MD_test(file, 1) MTMF_test(file, 1) file.write(\u0026#34;j b_test_{}_two\\n\u0026#34;.format(n)) R_test(file, 1) file.write(\u0026#34;\\nb_test_{}_two_then:\\n\u0026#34;.format(n)) R_test(file, 1) I_test(file, 1) LS_test(file, 1) shift_test(file, 1) MD_test(file, 1) MTMF_test(file, 1) file.write(\u0026#34;jal jal_test_{}\\n\u0026#34;.format(n)) file.write(\u0026#34;addu $1, $ra, $0\\n\u0026#34;) file.write(\u0026#34;\\njal_test_{}_then:\\n\u0026#34;.format(n)) R_test(file, 1) I_test(file, 1) LS_test(file, 1) shift_test(file, 1) MD_test(file, 1) MTMF_test(file, 1) file.write(\u0026#34;addiu $ra,$ra, 8\\n\u0026#34;.format(n)) B_test(file, \u0026#34;end_{}\u0026#34;.format(n)) R_test(file, 1) I_test(file, 1) LS_test(file, 1) shift_test(file, 1) MD_test(file, 1) MTMF_test(file, 1) file.write(\u0026#34;jr $ra\\n\u0026#34;.format(n)) with open(\u0026#34;mips_code.asm\u0026#34;, \u0026#34;w\u0026#34;) as file: for i in range(length): temp = random.randint(-2147483648, 2147483648) s = \u0026#34;li ${} {}\\n\u0026#34;.format(i, temp) file.write(s) file.write(\u0026#34;li $8, {}\\n\u0026#34;.format(random.randint(-2147483648, 2147483648) % 10000 + 1)) for i in range(10): R_test(file, 2) MD_test(file,1) MTMF_test(file, 1) I_test(file, 2) LS_test(file, 2) MTMF_test(file, 1) I_test(file, 2) shift_test(file, 2) file.write(\u0026#34;\\n\u0026#34;) 思考题 为什么需要有单独的乘除法部件而不是整合进 ALU？为何需要有独立的 HI、LO 寄存器？ [!ANS] 因为乘除操作较为复杂，需要多个周期才能完成，需要单独处理\n真实的流水线 CPU 是如何使用实现乘除法的？请查阅相关资料进行简单说明。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 `define size 8 module mul_booth_signed( input wire [`size - 1 : 0] mul1,mul2, input clk, input wire [2:0] clk_cnt,//运算节拍，相当于状态机了，8位的话每次运算有4个拍 output wire [2*`size - 1 : 0] res ); //由于传值默认就是补码，所以只需要再计算“负补码”即可 wire [`size - 1 : 0] bmul1,bmul2; assign bmul1 = (~mul1 + 1\u0026#39;b1) ; assign bmul2 = (~mul2 + 1\u0026#39;b1) ;//其实乘数2的负补码也没用到。 //其实可以把状态机的开始和结束状态都写出来，我懒得写了，同学们可以尝试一下啊~ parameter zeroone = 3\u0026#39;b00, twothree = 3\u0026#39;b001, fourfive = 3\u0026#39;b010, sixseven = 3\u0026#39;b011; //y(i-1),y(i),y(i+1)三个数的判断寄存器，由于有多种情况，也可以看成状态机（也可以改写成状态机形式，大家自己试试吧） reg [2:0] temp; //部分积 reg [2*`size-1 : 0] A; //每个节拍下把相应位置的数据传给temp寄存器 always @ (posedge clk) begin case(clk_cnt) zeroone : temp \u0026lt;= {mul2[1:0],1\u0026#39;b0}; twothree : temp \u0026lt;= mul2[3:1]; fourfive : temp \u0026lt;= mul2[5:3]; sixseven : temp \u0026lt;= mul2[7:5]; default : temp \u0026lt;= 0; endcase end always @(posedge clk) begin if (clk_cnt == 3\u0026#39;b100) begin//如果节拍到4就让部分积归0，此时已经完成一次计算了 A \u0026lt;= 0; end else case (temp) 3\u0026#39;b000,3\u0026#39;b111 : begin//这些是从高位到低位的判断，别看反了噢 A \u0026lt;= A + 0; end 3\u0026#39;b001,3\u0026#39;b010 : begin//加法操作使用补码即可，倍数利用左移解决 A \u0026lt;= A + ({{8{mul1[`size-1]}},mul1} \u0026lt;\u0026lt; 2*(clk_cnt-1)); end 3\u0026#39;b011 : begin A \u0026lt;= A + ({{8{mul1[`size-1]}},mul1} \u0026lt;\u0026lt; 2*(clk_cnt-1) + 1); end 3\u0026#39;b100: begin//减法操作利用“负补码”改成加法操作，倍数利用左移解决 A \u0026lt;= A + ({{8{bmul1[`size-1]}},bmul1} \u0026lt;\u0026lt; 2*(clk_cnt-1) + 1); end 3\u0026#39;b101,3\u0026#39;b110 : begin A \u0026lt;= A + ({{8{bmul1[`size-1]}},bmul1} \u0026lt;\u0026lt; 2*(clk_cnt-1)); end default: A \u0026lt;= 0; endcase end //当节拍到4的时候写入结果寄存器。 assign res = (clk_cnt == 3\u0026#39;b100) ? A : 0; endmodule 请结合自己的实现分析，你是如何处理 Busy 信号带来的周期阻塞的？ [!ANS] 修改P5中的Stall逻辑，当乘除槽处于start或busy状态，且ID级指令需要使用乘除槽时阻塞\n1 2 wire Stall_md = ((busy | start) \u0026amp; (mult_ID | multu_ID | div_ID | divu_ID | mfhi_ID | mflo_ID | mthi_ID | mtlo_ID)); assign Stall = Stall_RS_EX | Stall_RS_MA | Stall_RT_EX | Stall_RT_MA | Stall_md; 请问采用字节使能信号的方式处理写指令有什么好处？（提示：从清晰性、统一性等角度考虑） [!ANS] 更符合实际CPU电路，在实际电路中这样做更加高效。对于外部存储单元，其只需要读取使能信号然后进行相应存储即可，无需增加其他存储逻辑，使外部设备有较为统一的存储逻辑，便于扩展。\n请思考，我们在按字节读和按字节写时，实际从 DM 获得的数据和向 DM 写入的数据是否是一字节？在什么情况下我们按字节读和按字节写的效率会高于按字读和按字写呢？ [!ANS] 不是一字节。当存储容量较小时按字节读和写会更加高效, 不需要添加多余的逻辑。\n为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？ [!ANS]\n在高层模块的排布中就屏蔽了实现的细节，只保留了此模块的端口，以及端口的功能。 对于同一类型的指令增加多位宽type信号，功能模块根据不同type信号执行对应操作。例如：涉及乘除槽的指令，我设置一个mdOp信号来区分指令，从而减少了流水寄存器的接口数目，从而降低复杂度。 是否阻塞全部放到冲突处理模块判断，尽可能遵循“高内聚低耦合”的原则。 乘除槽与ALU分离，但是输出路径一致。不需要更改转发逻辑。 在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？ [!ANS] 涉及到HI和LO寄存器的指令与其他读写寄存器指令冲突。通过设置合理的阻塞逻辑解决。\n1 2 3 ori $2, $0, 128 lw $3, 0($0) mult $3, $2 如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证覆盖了所有需要测试的情况；如果你是完全随机生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了特殊的策略，比如构造连续数据冒险序列，请你描述一下你使用的策略如何结合了随机性达到强测的效果。 [!ANS] 我才用的方案是手动构造样例确保新指令的功能正确性，随机生成指令强测确保转发和阻塞的正确性。限制读写寄存器的范围，能够尽可能多的造成数据冒险，再加上大量随机数据，基本可以覆盖全部转发和阻塞情况。\n[P5、P6 选做] 请评估我们给出的覆盖率分析模型的合理性，如有更好的方案，可一并提出。 ","date":"2024-12-10T22:26:00Z","image":"https://lhy0424.top/p/co_p6/P6_cover_hu_6737325dc5752db4.jpg","permalink":"https://lhy0424.top/p/co_p6/","title":"P6_设计文档"},{"content":"P5_document Hazard.v input explain Instr_ID ID阶段的指令码 Instr_EX EX阶段的指令码 Instr_MA MA阶段的指令码 A3_EX EX阶段的寄存器写入地址 A3_MA MA阶段的寄存器写入地址 T_use表格（需求者） 指令位于ID级时，还需要多少个周期才必须要使用数据。\n$T_{use}(rs)$ $T_{use}(rt)$ add 1 1 sub 1 1 ori 1 lw 1 sw 1 2 beq 0 0 lui 1 jal jr 0 nop 1 2 3 4 5 6 7 8 wire [1:0] Tuse_rs = (add_ID | sub_ID | ori_ID | lw_ID | sw_ID | lui_ID)?2\u0026#39;b01: (beq_ID | jr_ID)? 2\u0026#39;b00: 2\u0026#39;b11; wire [1:0] Tuse_rt = (add_ID | sub_ID)? 2\u0026#39;b01: (sw_ID)? 2\u0026#39;b10: (beq_ID)? 2\u0026#39;b00: 2\u0026#39;b11; T_new表格（供给者） T_new: 供给指令位于某个流水级时还需要多少个周期才可以计算出结果并存储到流水寄存器中。\n早于需求指令进入流水线的供给者还需要多少cycle能够产生需求者需要的寄存器值。\nIntsr 功能部件(结果来源) EX MA WB add ALU 1 sub ALU 1 ori ALU 1 lw DM 2 1 0 sw beq lui ALU 1 jal PC 0 0 0 jr nop 1 2 3 wire [1:0] Tnew_EX = (add_EX | sub_EX | ori_EX | lui_EX)? 2\u0026#39;b01: (lw_EX)? 2\u0026#39;b10: 2\u0026#39;b00; wire [1:0] Tnew_MA = lw_MA?2\u0026#39;b01:2\u0026#39;b00; rs策略矩阵 $T_{use} \\textbackslash \\space T_{new}$ EX EX EX MA MA MA WB WB WB ALU DM PC ALU DM PC ALU DM PC 1 2 0 0 1 0 0 0 0 0 S S F F S F F F F 1 F S F F F F F F F rt策略矩阵 $T_{use} \\textbackslash \\space T_{new}$ EX EX EX MA MA MA WB WB WB ALU DM PC ALU DM PC ALU DM PC 1 2 0 0 1 0 0 0 0 0 S S F F S F F F F 1 F S F F F F F F F 2 F F F F F F F F F 如何理解策略矩阵 策略矩阵针对的是AT法中的Time部分，具体判断阻塞还是转发需要综合Adress部分 对于ALU型指令，如add，只需要关注 $T_{new}$ 的ALU一列，其表示在当前流水级下，还有多少周期才能计算出结果并存入流水级寄存器。 1 2 3 4 5 6 wire Stall_RS_EX = (Tuse_rs \u0026lt; Tnew_EX) \u0026amp; (A3_EX == RS_ID \u0026amp; RS_ID != 0); wire Stall_RS_MA = (Tuse_rs \u0026lt; Tnew_MA) \u0026amp; (A3_MA == RS_ID \u0026amp; RS_ID != 0); wire Stall_RT_EX = (Tuse_rt \u0026lt; Tnew_EX) \u0026amp; (A3_EX == RT_ID \u0026amp; RT_ID != 0); wire Stall_RT_MA = (Tuse_rt \u0026lt; Tnew_MA) \u0026amp; (A3_MA == RT_ID \u0026amp; RT_ID != 0); assign Stall = Stall_RS_EX | Stall_RS_MA | Stall_RT_EX | Stall_RT_MA; Forward in mips.v 数据的供给者 EX_MA级流水线寄存器 1 2 3 wire [31:0] forward_EX_MA = (RegWrite_MA \u0026amp;\u0026amp; (Mem2Reg_MA == 2\u0026#39;b00))? ALU_C_MA: (RegWrite_MA \u0026amp;\u0026amp; (Mem2Reg_MA == 2\u0026#39;b10))? pc_add4_MA + 32\u0026#39;d4: 32\u0026#39;h404; MA_WB级流水线寄存器 1 2 3 4 5 assign grf_WD = (Mem2Reg_WB == 2\u0026#39;b00) ? ALU_C_WB : (Mem2Reg_WB == 2\u0026#39;b01) ? dm_data_WB : (Mem2Reg_WB == 2\u0026#39;b10) ? pc_add4_WB + 32\u0026#39;d4 : 32\u0026#39;d0; wire [31:0] forward_MA_WB = RegWrite_WB? grf_WD: 32\u0026#39;h405; 数据需求者 ID级 1 2 3 4 5 6 7 wire [31:0] RD1_ID_valid = ((RS_ID == A3_MA) \u0026amp;\u0026amp; (A3_MA != 5\u0026#39;b0))? forward_EX_MA: ((RS_ID == A3_WB) \u0026amp;\u0026amp; (A3_WB != 5\u0026#39;b0))? forward_MA_WB: RD1_ID; wire [31:0] RD2_ID_valid = ((RT_ID == A3_MA) \u0026amp;\u0026amp; (A3_MA != 5\u0026#39;b0))? forward_EX_MA: ((RT_ID == A3_WB) \u0026amp;\u0026amp; (A3_WB != 5\u0026#39;b0))? forward_MA_WB: RD2_ID; EX级 1 2 3 4 5 6 7 8 9 10 11 12 13 //forward--select valid ALU_A and ALU_B wire [31:0] ALU_A_EX_valid = ((RS_EX == A3_MA) \u0026amp;\u0026amp; (A3_MA != 5\u0026#39;b0))? forward_EX_MA: ((RS_EX == A3_WB) \u0026amp;\u0026amp; (A3_WB != 5\u0026#39;b0))? forward_MA_WB: RD1_EX; wire [31:0] Grt_EX_valid = ((RT_EX == A3_MA) \u0026amp;\u0026amp; (A3_MA != 5\u0026#39;b0))? forward_EX_MA: ((RT_EX == A3_WB) \u0026amp;\u0026amp; (A3_WB != 5\u0026#39;b0))? forward_MA_WB: RD2_EX;//将目前正确的Grt值，流水到MA级供sw指令使用，也可供R-type-ALU指令使用 wire [31:0] Grt_MA_valid; wire [31:0] ALU_B_EX_valid = (ALUSrc_EX == 1\u0026#39;b0) ? Grt_EX_valid: (ALUSrc_EX == 1\u0026#39;b1) ? ext32_EX : 32\u0026#39;b0; MA级\n再一次获取转发数据，确保DM中的Grt值是正确的\n1 wire [31:0] Grt_MA_valid_valid = ((RT_MA == A3_WB) \u0026amp;\u0026amp; (A3_WB != 5\u0026#39;d0))? forward_MA_WB: Grt_MA_valid; 流水线寄存器 PC IF_ID ID_EX EX_MA MA_WB en nStall nStall true false true clr null false Stall true false RegDst ExtOp jump jumpSrc branch bOp ALUSrc ALUOP MemWrite ls_type Mem2Reg RegWrite 作用阶段 EX ID ID ID ID ID EX EX MA MA WB WB IF_ID ID_EX 1 1 1 1 1 1 1 EX_MA 1 1 1 1 MA_WB 1 1 Stall Explain ID级指令静止，EX级插入一个nop\nPC不写入新数据 IF_ID寄存器不写入新数据 ID_EX寄存器清零，即插入nop(0x00000000) Logic 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 module Stage_Reg( input clk, input reset, input en, input clr, input [31:0] data, output reg [31:0] data_out ); initial begin data_out \u0026lt;= 0; end always @(posedge clk) begin if (reset || clr) begin data_out \u0026lt;= 0; end else begin if (en) begin data_out \u0026lt;= data; end end end 信号解释 jumpSrc (2-bit) jumpSrc type 2\u0026rsquo;b00 branch 2\u0026rsquo;b01 jump 2\u0026rsquo;b10 jr 1 2 3 assign next_pc_ID = (jumpSrc_ID == 2\u0026#39;b00) ? branch_offset_ID: (jumpSrc_ID == 2\u0026#39;b01) ? jumpExt32_ID: (jumpSrc_ID == 2\u0026#39;b10) ? RD1_ID_valid: 32\u0026#39;h404; Mem2Reg (2-bit) Mem2Reg type 2‘b00 ALU 2\u0026rsquo;b01 lw 2\u0026rsquo;b10 link 1 2 3 assign grf_WD = (Mem2Reg_WB == 2\u0026#39;b00) ? ALU_C_WB : (Mem2Reg_WB == 2\u0026#39;b01) ? dm_data_WB : (Mem2Reg_WB == 2\u0026#39;b10) ? pc_add4_WB + 32\u0026#39;d4 : 32\u0026#39;d0; RegDst (2-bit) RegDst type 2\u0026rsquo;b00 无需写入寄存器的指令 2\u0026rsquo;b01 R-type，写入rd寄存器 2\u0026rsquo;b10 I-type，写入rt寄存器 2\u0026rsquo;b11 link，写入$ra ($31) 1 2 3 4 5 assign A3_EX = (RegDst_EX == 2\u0026#39;b00)? 5\u0026#39;b0: //null (RegDst_EX == 2\u0026#39;b01)? RD_EX: (RegDst_EX == 2\u0026#39;b10)? RT_EX: (RegDst_EX == 2\u0026#39;b11)? 5\u0026#39;h1f: 5\u0026#39;b00000; ALU (4-bit) ALU type 4\u0026rsquo;b0000 add 4\u0026rsquo;b0001 sub 4\u0026rsquo;b0010 or 4\u0026rsquo;b0011 lui 1 2 3 4 5 6 7 8 9 always @(*) begin case(F) `ADD: C = A + B; `SUB: C = A - B; `OR: C = A | B; `SL16: C = B \u0026lt;\u0026lt; 16; default:C = 0; endcase end 测试方案 指令分类 R-type ALU型指令（Grd \u0026lt;- Grs ? Grt）——（add、sub、or） ALU型指令（Grd \u0026lt;- Grt ？ shamt）——（sll、srl、sra） 跳转型指令（PC \u0026lt;- Grs）——（jr） I-type ALU-Imm型指令（Grt \u0026lt;- Grs ？ imm）——（ori、lui） Memory-Store型指令（Memory[Grs + offset] \u0026lt;- Grt）——（sw、sb、sh） Memory-load型指令（Grt \u0026lt;- Memory[Grs + offset]）——（lw、lb、lbu、lh） Branch型指令（Grs ? Grt，PC \u0026lt;- PC + 4 + offset）——（beq、bgez、bgtz、blez、bltz、bne） J-type J-link型指令 —— (jal) 无条件Jump型指令 IF级 ID级 EX级 MA级 WB级 R-ALU 读取数据（Grs、Grt） 计算数据 写入数据 R-jump 读取数据并跳转 I-imm 读取数据（Grt、imm） 计算数据 写入数据 I-store 读取数据（Grs+offset、Grt） 计算数据（地址） 写入数据 I-load 读取数据（Grs+offset、Grt） 计算数据（地址） 读取数据 写入数据 I-branch 读取数据（Grs、Grt）比较数据并跳转 J-link 扩展数据并跳转 传递跳转PC 传递跳转PC 写入pc+8 测试步骤 编写测试代码 包括所有阻塞情况 测试所有转发通路 可利用课程组提供的分析工具对代码测试强度进行评估 将ISE输出与Mars输出比对 可利用同学开发评测机进行快速比对 大量随机数据强测 代码生成思路参照P4数据生成思路 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import random SUPPORTED_INSTRUCTIONS = [ \u0026#34;add\u0026#34;, \u0026#34;sub\u0026#34;, \u0026#34;and\u0026#34;, \u0026#34;ori\u0026#34;, \u0026#34;lui\u0026#34;, # arithmetic \u0026#34;lw\u0026#34;, \u0026#34;sw\u0026#34;, # storage \u0026#34;beq\u0026#34;, \u0026#34;bne\u0026#34;, # B-type \u0026#34;j\u0026#34;, \u0026#34;jal\u0026#34;, # jump \u0026#34;nop\u0026#34; # command jr will be generated according to the use of command jal ] REGISTERS = [f\u0026#34;${i}\u0026#34; for i in range(32) if i != 1 and i \u0026lt; 26] def weighted_choice(): return random.choices(REGISTERS, weights=REGISTER_WEIGHTS, k=1)[0] def generate_random_instruction(half): instruction = random.choice(SUPPORTED_INSTRUCTIONS) if instruction in [\u0026#34;add\u0026#34;, \u0026#34;sub\u0026#34;, \u0026#34;and\u0026#34;]: # add $t0, $t1, $t2 : op rd, rs, rt rd = weighted_choice() rs = weighted_choice() rt = weighted_choice() return f\u0026#34;{instruction} {rd}, {rs}, {rt}\u0026#34; # other instructions... def main(): # parser... high_weight_registers = random.sample(REGISTERS, 4) # print(f\u0026#34;High weight registers: {high_weight_registers}\u0026#34;) global REGISTER_WEIGHTS REGISTER_WEIGHTS = [4 if reg in high_weight_registers else 1 for reg in REGISTERS] mips_code = generate_mips_code(args.num_instructions) 思考题 我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。 提前分支判断会带增加阻塞的情况，从而降低效率\nlw $1, 0($0) ori $2, $0, 514 beq $1, $2, label\n对于上述代码，需要阻塞两次\n因为延迟槽的存在，对于 jal 等需要将指令地址写入寄存器的指令，要写回 PC + 8，请思考为什么这样设计？ 因为，jr返回时应该执行延迟槽后面的指令\n我们要求所有转发数据都来源于流水寄存器而不能是功能部件（如 DM、ALU），请思考为什么？ 减少组合逻辑与时序逻辑的组合，减少毛刺，使流水线分级更清晰\n我们为什么要使用 GPR 内部转发？该如何实现？ 解决结构冒险。由于流水线中grf的读写在不同级，所以当同时读和写grf时会出现结构冒险\nassign RD1 = (A3!=0 \u0026amp; A1==A3 \u0026amp; WE) ? WD : grf[A1];\nassign RD2 = (A3!=0 \u0026amp; A2==A3 \u0026amp; WE) ? WD : grf[A2];\n我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？ 见上文\n在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。 添加控制信号 可能需要修改ALU 修改顶层模块，可能需要添加wire 可能需要修改阻塞逻辑 简要描述你的译码器架构，并思考该架构的优势以及不足。、 集中式译码。只需一次译码，然后流水各个信号。 优势：资源占用小，代码量小 不足：流水信号比较麻烦，添加控制信号时比较麻烦\n[P5 选做] 请详细描述你的测试方案及测试数据构造策略。 见测试方案\n[P5、P6 选做] 请评估我们给出的覆盖率分析模型的合理性，如有更好的方案，可一并提出。 ","date":"2024-11-14T00:11:00Z","image":"https://lhy0424.top/p/co_p5/P5_cover_hu_c8bd981175408345.jpg","permalink":"https://lhy0424.top/p/co_p5/","title":"P5_设计文档"},{"content":"P4_L0_document 信号解释 RegDst（寄存器写入地址） 2\u0026rsquo;b00: RT 2\u0026rsquo;b01: RD 2\u0026rsquo;b11: 5\u0026rsquo;h1f default: 5\u0026rsquo;b0 Mem2Reg（寄存器写入数据） 2\u0026rsquo;b00: alu_c 2\u0026rsquo;b01: dm_data 2\u0026rsquo;b10: pc + 32\u0026rsquo;d4 default: 32\u0026rsquo;b0 ALUSrc（alu的b操作数选择） 1\u0026rsquo;b0: grf_RD2 1\u0026rsquo;b1: ext_ext32 default: 32\u0026rsquo;b0 ALU_F（ALU计算方式） 4\u0026rsquo;b0000: add 4\u0026rsquo;b0001: sub 4\u0026rsquo;b0010: or 4\u0026rsquo;b0011: SL16 (lui) 4\u0026rsquo;b0100: SLL (补0逻辑左移) 4’b0101: SRL (补0逻辑右移) 4‘b0110: SRA (算数右移) ExtOp (扩展操作) 2’b01: 0扩展 2‘b10: 算术扩展（符号位） 2’b11: 1扩展 设计草稿 本次CPU支持add, sub, or, ori, lw, sw, lb, lbu, lh, sb, sh, beq, lui, nop，begz，bgtz，blez，bltz，bne, j, jal, jr共23条指令。\nmips.v (Top) Ports Port name Direction Type Description clk input reset input Signals Name Type Description pc wire [31:0] if_jump wire if_branch wire instr_out wire [31:0] ifu_offset wire [31:0] OPCODE wire [5:0] FUNCT wire [5:0] RS wire [4:0] RT wire [4:0] RD wire [4:0] SHAMT wire [4:0] IMM wire [15:0] INDEX wire [25:0] bOp_out wire [5:0] RegDst_out wire [1:0] ALUSrc_out wire Mem2Reg_out wire [1:0] RegWrite_out wire MemWrite_out wire branch_out wire ExtOp_out wire [1:0] ALUOP_out wire [1:0] jumpSrc_out wire [1:0] dm_data wire [31:0] ext_ext32 wire [31:0] grf_RD1 wire [31:0] grf_RD2 wire [31:0] alu_B wire [31:0] alu_C wire [31:0] grf_WA wire [4:0] grf_WD wire [31:0] jumpext_ext32 wire [31:0] Instantiations ifu: IFU\ncontroller: Controller\ngrf: GRF\nalu: ALU\ndm: DM\next: EXT\njumpext: jumpEXT\nbcheck: bCheck\nIFU.v Ports Port name Direction Type Description clk input reset input jump input branch input offset input [31:0] PC output [31:0] Instr output [31:0] Controller.v Ports Port name Direction Type Description OpCode input [5:0] Funct input [5:0] rt input [4:0] jump output jumpSrc output [1:0] bOp output [5:0] RegDst output [1:0] ALUSrc output Mem2Reg output [1:0] RegWrite output MemWrite output branch output ExtOp output [1:0] ALUOP output [1:0] 信号映射表 OpCode Funct RT add 000000 100000 sub 000000 100010 or 000000 100101 SLL 000000 000000 SRL 000000 000010 SRA 000000 000011 ori 001101 lw 100011 sw 101011 lb 100000 lbu 100100 lh 100001 sb 101000 sh 101001 beq 000100 lui 001111 bgez 000001 00001 bgtz 000111 blez 000110 bltz 000001 bne 000101 00000 jump 000010 jal 000011 jr 000000 001000 add sub ori SLL SRL SRA or lw sw lb lbu lh sb sh branch lui jump jal jr RegDst 01 01 00 01 01 01 01 00 00 00 00 00 00 00 00 00 00 11(const31) 00 ALUSrc 0 0 1 0 0 0 0 1 1 1 1 1 1 1 1 1 0 0 0 Mem2Reg 00 00 00 00 00 00 00 01 00 01 01 01 00 00 00 00 00 10(PC + 4) 00 RegWrite 1 1 1 1 1 1 1 1 0 1 1 1 0 0 0 1 0 1 0 MemWrite 0 0 0 0 0 0 0 0 1 0 0 0 1 1 0 0 0 0 0 branch 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 ExtOp 00 00 01(zero) 0 0 0 00 ]10(signed) 10(signed) 10 10 10 10 10 10(signed) 10(signed) 00 0 0 ALUOP\u0026lt;3,0\u0026gt; 0000 0001 0010 0100 0101 0110 0010 0000(+) 0000(+) 0000 0000 0000 0000 0000 0000(+) 0011 0000 0000 0000 jumpSrc 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01 01 10 jump 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 ls_type 00 00 01 10 11 01 11 GRF.v Ports Port name Direction Type Description A1 input [4:0] A2 input [4:0] A3 input [4:0] WD input [31:0] clk input reset input WE input pc input [31:0] RD1 output [31:0] RD2 output [31:0] DM.v Ports Port name Direction Type Description A input [31:0] D_input input [31:0] str input clk input pc input [31:0] D_output output [31:0] ALU.v Ports Port name Direction Type Description A input [31:0] B input [31:0] shamt input [4:0] F input [3:0] C output [31:0] bCheck.v Ports Port name Direction Type Description Grs input [31:0] Grt input [31:0] bOp input [5:0] branch input check output EXT.v Ports Port name Direction Type Description imm16 input [15:0] ExtOp input [1:0] ext32 output [31:0] jumpEXT.v Ports Port name Direction Type Description index input [25:0] pc input [31:0] ext32 output [31:0] 测试方案 利用魔改Mars： 直接比较ISE得输出和Mars的输出\n***课上环境：***在Isim中将32个Reg和内存添加到波形图中，对比最终结果\n简单的测试代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 #GRF REG_WRITE TEST ori $1, 125 ori $2, 300 ori $3, $0, 5 ori $4, $0, 1024 ori $5, $0, 56 ori $6, $0,125 ori $7, $0, 525 ori $8, $0, 10086 ori $9, $0,14514 ori $10, $0, 625 ori $11, $0, 168 ori $12, $0, 576 ori $13, $0, 2048 ori $14, $0, 6666 ori $15, $0, 424 ori $16, $0, 2024 ori $16, $0, 1101 ori $17, $0, 2203 ori $18, $0, 2306 ori $19, $0, 999 ori $20, $0, 2005 ori $21, $0, 0 ori $22, $0, 176 ori $23, $0, 616 ori $24, $0, 1213 ori $25, $0, 1314 ori $26, $0, 888 ori $27, $0, 545 ori $28, $0, 28 #LUI TEST lui $1, 424 lui $12, 500 lui $24, 233 #ADD or SUB TEST add $21, $27, $28 sub $21, $27, $28 #MEMORY TEST sw $21, 0($0) lw $28, 0($0) #BRANCH TEST beq $24, $25, beq_label_false ori $24, $0, 1314 beq $24, $25, beq_label_true beq_label_false: ori $5, $0, 666 beq_label_true: ori $5, $0, 667 #JUMP TEST jal function ori $5, $0, 0 ori $5, $0, 1 ori $5, $0, 9 j jump_label function: ori $5, $0, 1111 jr $ra jump_label: nop nop nop bgez $0, bgez_label ori $1, $0, 11451 bgez_label: ori $1, $0, -10 bltz $1, bltz_label ori $5, $0, 1314 ori $6, $0, 156 bltz_label: bne $0, $1, bne_label ori $5, $0, 131 ori $6, $0, 15 bne_label: lui $12, 2333 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 //STDOUT @00003000: $ 1 \u0026lt;= 0000007d @00003004: $ 2 \u0026lt;= 0000012c @00003008: $ 3 \u0026lt;= 00000005 @0000300c: $ 4 \u0026lt;= 00000400 @00003010: $ 5 \u0026lt;= 00000038 @00003014: $ 6 \u0026lt;= 0000007d @00003018: $ 7 \u0026lt;= 0000020d @0000301c: $ 8 \u0026lt;= 00002766 @00003020: $ 9 \u0026lt;= 000038b2 @00003024: $10 \u0026lt;= 00000271 @00003028: $11 \u0026lt;= 000000a8 @0000302c: $12 \u0026lt;= 00000240 @00003030: $13 \u0026lt;= 00000800 @00003034: $14 \u0026lt;= 00001a0a @00003038: $15 \u0026lt;= 000001a8 @0000303c: $16 \u0026lt;= 000007e8 @00003040: $16 \u0026lt;= 0000044d @00003044: $17 \u0026lt;= 0000089b @00003048: $18 \u0026lt;= 00000902 @0000304c: $19 \u0026lt;= 000003e7 @00003050: $20 \u0026lt;= 000007d5 @00003054: $21 \u0026lt;= 00000000 @00003058: $22 \u0026lt;= 000000b0 @0000305c: $23 \u0026lt;= 00000268 @00003060: $24 \u0026lt;= 000004bd @00003064: $25 \u0026lt;= 00000522 @00003068: $26 \u0026lt;= 00000378 @0000306c: $27 \u0026lt;= 00000221 @00003070: $28 \u0026lt;= 0000001c @00003074: $ 1 \u0026lt;= 01a80000 @00003078: $12 \u0026lt;= 01f40000 @0000307c: $24 \u0026lt;= 00e90000 @00003080: $21 \u0026lt;= 0000023d @00003084: $21 \u0026lt;= 00000205 @00003088: *00000000 \u0026lt;= 00000205 @0000308c: $28 \u0026lt;= 00000205 @00003094: $24 \u0026lt;= 00000522 @000030a0: $ 5 \u0026lt;= 0000029b @000030a4: $31 \u0026lt;= 000030a8 @000030b8: $ 5 \u0026lt;= 00000457 @000030a8: $ 5 \u0026lt;= 00000000 @000030ac: $ 5 \u0026lt;= 00000001 @000030b0: $ 5 \u0026lt;= 00000009 @000030d4: $ 1 \u0026lt;= ffff0000 @000030d8: $ 1 \u0026lt;= fffffff6 @000030dc: $ 1 \u0026lt;= fffffff6 @000030f8: $12 \u0026lt;= 091d0000 思考题 阅读下面给出的 DM 的输入示例中（示例 DM 容量为 4KB，即 32bit × 1024字），根据你的理解回答，这个 addr 信号又是从哪里来的？地址信号 addr 位数为什么是 [11:2] 而不是 [9:0] ？\naddr信号来源于ALU的结果输出端。\n输入信号为按字节索引的地址，而DM的存储方式为按字索引，取addr[11:2]即等于addr[9:0] \u0026laquo; 2\n思考上述两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 always @(*) begin if (OpCode == 6\u0026#39;b000000) begin if (Funct == 6\u0026#39;b100000) begin //add RegDst \u0026lt;= 2\u0026#39;b01; ALUSrc \u0026lt;= 1\u0026#39;b0; Mem2Reg \u0026lt;= 2\u0026#39;b00; RegWrite \u0026lt;= 1\u0026#39;b1; MemWrite \u0026lt;= 1\u0026#39;b0; branch \u0026lt;= 1\u0026#39;b0; ExtOp \u0026lt;= 2\u0026#39;b00; ALUOP \u0026lt;= 2\u0026#39;b00; jumpSrc \u0026lt;= 2\u0026#39;b00; jump \u0026lt;= 1\u0026#39;b0; end end 1 2 3 4 5 6 7 8 9 10 11 12 13 14 always @(*) begin if (OpCode == 6\u0026#39;b100011 || OpCode == 6\u0026#39;b101011 || OpCode == 6\u0026#39;b000100 || OpCode == 6\u0026#39;b001111) begin ExtOp \u0026lt;= 2\u0026#39;b10; end else if (OpCode == 6\u0026#39;b001101) begin ExtOp \u0026lt;= 2\u0026#39;b01; end else begin ExtOp \u0026lt;= 2\u0026#39;b00; end end 记录指令对应的控制信号如何取值：方便添加新指令。 记录控制信号每种取值所对应的指令：方便添加控制信号。 在相应的部件中，复位信号的设计都是同步复位，这与 P3 中的设计要求不同。请对比同步复位与异步复位这两种方式的 reset 信号与 clk 信号优先级的关系。\n异步复位reset信号优先，同步复位clk信号优先。\nC 语言是一种弱类型程序设计语言。C 语言中不对计算结果溢出进行处理，这意味着 C 语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持 C 语言，MIPS 指令的所有计算指令均可以忽略溢出。 请说明为什么在忽略溢出的前提下，addi 与 addiu 是等价的，add 与 addu 是等价的。提示：阅读《MIPS32® Architecture For Programmers Volume II: The MIPS32® Instruction Set》中相关指令的 Operation 部分。\nThe term “unsigned” in the instruction name is a misnomer; this operation is 32-bit modulo arithmetic that does not trap on overflow. This instruction is appropriate for unsigned arithmetic, such as address arithmetic, or integer arithmetic environments that ignore overflow, such as C language arithmetic.\naddu和add的区别、addi和addiu的区别均仅在与是否有溢出判断，故忽略溢出时效果是一样的。\n","date":"2024-11-02T18:06:00Z","image":"https://lhy0424.top/p/co_p4/P4_cover_hu_61040807f1a1bf62.jpg","permalink":"https://lhy0424.top/p/co_p4/","title":"P4_设计文档"},{"content":"如何优雅地编写Verilog 一、替换ISE默认编辑器 ISE仿佛知道自己的默认编辑器很难用，所以允许用户自定义编辑器（\n打开ISE，上方工具栏Edit -\u0026gt; Preferences，在左侧Category选择ISE General -\u0026gt; Editors，第一栏下拉选项选择Custom，在后面一栏输入编辑器的路径，我们以sublime为例，格式如下（大括号内为自己的路径）\n{D:\\sublime\\Sublime Text\\sublime_text.exe} +$2 $1\n设置完成后我们在ISE中点击自己verilog文件就可以自动跳转至指定编辑器了\nsublime默认并不支持verilog文件，所以我们还需要安装相关插件\n这些插件可以实现基本的语法补全、代码高亮等功能，效果如下\n在编辑器编辑完保存后，我们可以返回ISE进行后续的仿真、查看波形图等功能。\n二、强大的VScode插件——TerosHDL 具体配置过程见官网：TerosHDL\n除了基础的语法补全功能，该插件提供如下功能：\n显示项目中各个模块或文件之间的层次结构和依赖关系\n实时错误检查\n自动模板用于testbench等\n自动生成文档\n生成状态机的状态转移图\n代码格式化\n生成原理图\n以及许多编辑工具：语法高亮、悬停提示、名称重构、名称重构、代码折叠、求值字面量\n此外，这款插件还可以集成外部工具，如使用iverilog编译、GTKWave查看波形，而且好像还支持ISE的命令行工具？期待大家进一步探索。\n三、VScode + ISE命令行工具 TerosHDL的配置比较麻烦，如果想简单一点，可以使用VScode + ISE命令行工具\n详情请见大佬的帖子,通过命令行，更优雅地利用ISE进行开发\n在VScode中编写verilog文件后，直接在VScode中新建一个.bat文件，复制以下内容，然后在文件资源管理器中双击打开即可实现一键编译、仿真、查看波形，基本可以脱离ISE。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @echo off REM 编译 \u0026#34;%XILINX%\\bin\\nt64\\fuse.exe\u0026#34; -nodebug -prj mips.prj -o mips.exe mips_tb IF ERRORLEVEL 1 ( echo 编译失败，请检查错误。 pause ) REM 运行仿真 mips.exe -nolog -tclbatch mips.tcl IF ERRORLEVEL 1 ( echo 仿真失败，请检查错误。 pause ) REM 查看波形 \u0026#34;%XILINX%\\bin\\nt64\\isimgui.exe\u0026#34; -view isim.wdb IF ERRORLEVEL 1 ( echo 查看波形失败，请检查错误。 pause ) pause REM 暂停，以便查看输出 ","date":"2024-11-02T18:06:00Z","image":"https://lhy0424.top/p/verilog_edit/vscode_teros_cover_hu_24a740a5d5f31a09.png","permalink":"https://lhy0424.top/p/verilog_edit/","title":"如何优雅地编写Verilog"},{"content":"P3_document 设计草稿 本次P3搭建的CPU支持add, sub, ori, lw, sw, beq, lui, nop，begz，bgtz，blez，bltz，bne, j, jal\nIFU (Instruction Fetch Unit) PC和nPC内置在IFU中，通过branch信号控制PC变换逻辑\n端口 方向 描述 Instr[31:0] O 输出32位指令二进制编码 offset[31:0] I 输入branch指令的地址偏移量 reset I 复位信号 branch I 是否branch PC O 用于测试PC Controller 用于控制信息通路中的多路选择器，选择正确的功能\nadd sub ori lw sw beq lui bgez bgtz blez bltz bne jump jal OpCode 000000 000000 001101 100011 101011 000100 001111 000001 000111 000110 000001 000101 000010 000011 Function 100000 100010 xxxxxx xxxxxx xxxxxx xxxxxx xxxxxx 00001 xxxxxx xxxxxx 00000 xxxxxx xxxxxx xxxxxx add sub ori lw sw branch lui jump jal RegDst 01 01 00 00 00 00 00 00 11(const31) ALUSrc 0 0 1 1 1 1 1 0 0 Mem2Reg 00 00 00 01 00 00 00 00 10(PC + 4) RegWrite 1 1 1 1 0 0 1 0 1 MemWrite 0 0 0 0 1 0 0 0 0 nPC_Sel 0 0 0 0 0 1 0 0 0 ExtOp 00 00 01(zero) 10(signed) 10(signed) 10(signed) 10(signed) 00 0 ALUOP\u0026lt;1,0\u0026gt; 00 01 10 00(+) 00(+) 00(+) 11 00 0 jump 0 0 0 0 0 0 0 1 1 beq bgez bgtz blez bltz bne bOp 100000 010000 001000 000100 000010 000001 GRF (General Register File) 引用自P0_Q2\nGRF中包含32个32位寄存器，分别对应0~31号寄存器，其中0号寄存器读取的结果恒为0。\nALU (Arithmetic Logic Unit) ALUOP 描述 00 加法 01 减法 10 或 11 立即数加载到高位 EXT (Extend) 用于数据扩展\nExtOp 操作 00 无操作 01 0扩展 10 signed扩展 11 1扩展 bChecker (Branch Checker) 用于判断是否跳转\n端口 方向 描述 bOp I 连接到Controller.bOp，获取branch类型 branch I 连接到Controller.branch，判断是否是branch信号 G[rs] I 连接到GRF.RD1 G[rt] I 连接到GFR.RD2 check O 判断是否符合branch条件，连接到IFU.branch jumpEXT 用于实现jump和jal指令，计算 PC31\u0026hellip;28 || Instr_index || 00\n端口 方向 描述 index I 获取Instr_index，即机器码的后26位 PC I 获取PC的值 ext32 O 下一个PC的值（nPC） 测试方案 随机生成数据 -\u0026gt; 导出十六进制文件 -\u0026gt; 自动化工具生成新电路 -\u0026gt; 比对mars运行结果和circ运行结果\nrandomMipsCmd.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 import random import time def generate_register(): \u0026#34;\u0026#34;\u0026#34;生成一个随机寄存器编号（0-31）。\u0026#34;\u0026#34;\u0026#34; return random.randint(0, 31) def generate_immediate(): \u0026#34;\u0026#34;\u0026#34;生成一个随机立即数（0-65535）。\u0026#34;\u0026#34;\u0026#34; return random.randint(0, 65535) def generate_memory_address(): \u0026#34;\u0026#34;\u0026#34;生成一个随机内存地址（0-3071，左移2位）。\u0026#34;\u0026#34;\u0026#34; return random.randint(0, 3071) \u0026lt;\u0026lt; 2 def write_instruction(file, instruction): \u0026#34;\u0026#34;\u0026#34;将指令写入文件。\u0026#34;\u0026#34;\u0026#34; file.write(instruction + \u0026#34;\\n\u0026#34;) def main(): random.seed(time.time()) length = int(input(\u0026#34;请输入要生成的指令数量：\u0026#34;)) label_count = 0 with open(\u0026#34;result.asm\u0026#34;, \u0026#34;w\u0026#34;) as file: for _ in range(length): tmp = random.randint(0, 8) match tmp: case 0: write_instruction(file, f\u0026#34;add ${generate_register()}, ${generate_register()}, ${generate_register()}\u0026#34;) case 1: write_instruction(file, f\u0026#34;sub ${generate_register()}, ${generate_register()}, ${generate_register()}\u0026#34;) case 2: write_instruction(file, f\u0026#34;ori ${generate_register()}, ${generate_register()}, {generate_immediate()}\u0026#34;) case 3: write_instruction(file, f\u0026#34;lw ${generate_register()}, {generate_memory_address()}($0)\u0026#34;) case 4: write_instruction(file, f\u0026#34;sw ${generate_register()}, {generate_memory_address()}($0)\u0026#34;) case 5: if label_count \u0026gt;= 1: num1 = generate_register() num2 = generate_register() while num2 == num1: num2 = generate_register() write_instruction(file, f\u0026#34;ori ${num1}, ${num1}, {generate_immediate()}\u0026#34;) write_instruction(file, f\u0026#34;beq ${num1}, ${num2}, label{random.randint(0, label_count - 1)}\u0026#34;) case 6: write_instruction(file, f\u0026#34;lui ${generate_register()}, {generate_immediate()}\u0026#34;) case 7: write_instruction(file, \u0026#34;nop\u0026#34;) case 8: write_instruction(file, f\u0026#34;label{label_count}:\u0026#34;) label_count += 1 if __name__ == \u0026#39;__main__\u0026#39;: main() autoWrite2Rom.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import re # 读取 ROM 文件内容 with open(\u0026#34;python\\\\autoTest_P3\\\\rom.txt\u0026#34;, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: rom_content = f.read().strip() # 去掉前后空白字符 # 读取电路文件 with open(\u0026#34;python\\\\autoTest_P3\\\\cpu.circ\u0026#34;, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as cur_file: cur_content = cur_file.read() # 使用正则表达式替换 ROM 内容 cur_content = re.sub( r\u0026#39;addr/data: 12 32([\\s\\S]*?)\u0026lt;/a\u0026gt;\u0026#39;, # 使用非贪婪模式匹配 f\u0026#39;addr/data: 12 32\\n{rom_content}\\n\u0026lt;/a\u0026gt;\u0026#39;, cur_content, flags=re.DOTALL # 允许 . 匹配换行符 ) # 写入新的电路文件 with open(\u0026#34;cpu_remake.circ\u0026#34;, \u0026#34;w\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as file: file.write(cur_content) 思考题 上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法。请大家指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。\n状态存储功能：IFU、GRF 状态转移功能：Controller、ALU、EXT、bCheckTT 现在我们的模块中 IM 使用 ROM， DM 使用 RAM， GRF 使用 Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。\n合理\nROM是只读存储器，不会被写入，内部数据不会被修改，适合用来储存指令。 RAM可以存取存储器，可以被写入可以被读取，适合用来读取数据。 GRF是寄存器堆，Register具有较高的读写速度，适合用来存储指令中的数据。 在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。\n额外设计了Branch Checker，用于判断是否branch，设计思路见\u0026quot;设计草稿\u0026quot;\n事实上，实现 nop 空指令，我们并不需要将它加入控制信号真值表，为什么？\nnop的指令码是0x00000000，会被翻译为*** sll $0, $0 0***，即把$0的值左移0位存入$0，因为$0的值始终为零不会被改变，所以nop不会带来电路的任何改变。\n阅读 Pre 的 “MIPS 指令集及汇编语言” 一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。\n强度一般\n没有测试到所有的寄存器，也没有考虑到数据溢出的情况\n","date":"2024-10-27T17:53:00Z","image":"https://lhy0424.top/p/co_p3/P3_cover_hu_8f3ab4c5ecd92ea2.jpg","permalink":"https://lhy0424.top/p/co_p3/","title":"P3_设计文档"},{"content":"科研课题调研任务\n声明 为了公平起见，本次所比较的四个大模型均使用免费的默认模型（打开对应的网页直接使用）。\n所引用的回答均是首次回答。\n所有排行均是个人主观判断\n一、我对第六链的理解 在第五链中，作者着重介绍了“枢纽节点”，提出了对“随即网络”的质疑，并指出“枢纽节点服从严格的数学规律，枢纽节点的无处不在促使我们对网络进行全新的思考”。\n在第六链中，作者向我们介绍了复杂网络的分布规律——幂律。我认为对第六链的总结应包含以下几个方面：\n帕累托定律（80/20定律）与幂律的关系。幂律从数学角度验证了80/20定律：少数几个大事件发挥了大部分的作用。\n幂律分布与钟形分布与无尺度网络。钟形分布曲线有一个峰，这个峰代表所有节点的特征尺度，偏离这一尺度的事件很少发生；，幂律分布曲线没有峰，而是不断递减的曲线，在幂律分布中，大量微小事件和少数非常重大的事件并存，无法找到一个能代表所有节点特性的节点，即不存在固有的尺度，拥有这一分布特征的网络被称为“无尺度网络”。\n幂律分布网络的不均匀性。多数少链接节点和少数多链接节点（枢纽节点）并存，网络的连通性由少数枢纽节点保证，是它们让真实网络免于瓦解。\n无序到有序的涌现与自组织。在相变点，物质开始遵循相同的幂律，不同系统之间有着高度的相似。幂律是复杂系统自组织所独有的特性。\n幂律无处不在。在各个学科中，只要有自组织的现象，就存在幂律。\n二、文本阅读能力 epub文件来源于Z-Library，0.99MB\npdf文件由epub文件通过zamzar转换而来，5.20MB\n两个文件均为整本书\nChatGPT 通义千问 零一万物 腾讯元宝 epub文件阅读 ✗ ✓ ✗ ✗ pdf文件阅读 ✓ ✓ ✓ ✓ 文档大小 可上传20个文件，单个文件上限512MB 可上传100个文件，单个文件上限150MB 支持10个pdf同时上传，总页数上限5000（约500万字） 可上传50个文件，单个文件上限100MB 三、文本摘要能力 给出整本书的文件，仅总结第六链 epub - 通义千问 第六链讨论了幂律（Power Law）在复杂网络中的分布规律。幂律揭示了网络中节点的连接度分布并非随机，而是遵循一定的数学规律。这种规律体现在许多自然和社会现象中，比如财富分配、城市规模等，并且在网络科学中尤为重要。\n书中提到，帕累托（Pareto）和他的80/20定律是幂律的一个著名例子，即少数关键因素往往决定了大部分的结果。在复杂网络中，这意味着少数枢纽节点拥有大量的链接，而大多数节点只有很少的链接。这样的分布可以用概率形式表达，一个随机选择的节点恰好拥有k条链接的概率服从分布P(k)～k^(-γ)，其中γ被称为度指数。\n巴拉巴西等人发现，万维网的结构也符合幂律分布，这表明网络具有无尺度特性（scale-free），即网络中存在一些高度连接的节点（枢纽节点）。这些枢纽节点的存在使得网络表现出小世界特性，即任意两个节点之间的平均路径长度相对较短。此外，幂律分布还出现在其他系统中，如好莱坞演员的合作网络。\n幂律分布不仅是复杂网络的关键特征之一，也是理解网络健壮性与脆弱性的基础。它表明，虽然大多数节点对网络的整体连通性影响不大，但枢纽节点对于保持网络的完整性和功能性至关重要。如果枢纽节点被移除，整个网络可能会分裂成碎片。因此，幂律分布为我们提供了关于如何设计更加鲁棒的网络以及如何更有效地分析和控制网络的洞见。\n通义千问对epub文件的总结很详细，但显然没抓住了本章的重点，且忽略了一部分内容。此外，通义千问还擅自加入了一些额外的内容，如“提供了关于如何设计更加鲁棒的网络以及如何更有效地分析和控制网络的洞见”，这些概念并没有在文件中出现。\npdf - ChatGPT 第六链《幂律——复杂网络的分布规律》讨论了复杂网络中的一个重要特性——幂律分布。幂律规律揭示了在复杂系统中，少数节点会拥有大量连接，而大多数节点则只有少量连接。该规律与帕累托的80/20定律类似，表现为少部分节点掌握了大部分连接。通过幂律分布，我们可以看到有序是如何从无序中涌现出来的，从看似随机的结构中，复杂网络逐渐自组织并展现出稳定的分布模式。\n在这一链中，书中通过多个案例讨论了幂律分布的普遍性，包括互联网的连接分布、社交网络的关系模式等，强调了这种分布在现实世界中的无处不在。\nChatGPT的回答很简短，但却最能抓住重点，基本覆盖了本章的所有重要内容。个人认为是最佳回答。\npdf - 通义千问 第六链主要讨论了复杂网络中的幂律分布规律。这一章节揭示了在许多真实世界的网络中，节点的连接度（即一个节点与其他节点相连的数量）并不是均匀分布的，而是遵循一种特定的数学模式——幂律分布。幂律分布意味着少数节点拥有大量的链接，而大多数节点只有很少的链接。这种分布通常用P(k)～k^(-γ)来表示，其中P(k)是具有k个链接的节点的概率，γ是一个大于1的常数，称为度指数。\n书中提到，幂律分布在多种系统中都有出现，包括互联网、社交网络、细胞内的分子网络等。例如，在万维网中，少量网页成为了非常受欢迎的中心节点，它们被大量其他网页所链接，而绝大多数网页则相对较少地被链接。这样的结构被称为无尺度网络，它与传统的随机网络模型有很大的不同。\n此外，本章还探讨了幂律分布如何从无序中涌现有序，并且解释了生长机制和偏好连接是形成这种分布的两个重要原则。这意味着网络中的新节点更倾向于与那些已经拥有许多链接的节点建立联系，从而加强了这些中心节点的重要性，导致“富者愈富”的现象。这一过程也体现了“适者愈富”或“胜者通吃”的动态，其中某些节点能够迅速成长为网络中的关键枢纽。\n通义千问对pdf的总结不如epub，把重点放在了介绍“什么是幂律分布”，忽略了一部分内容，不像是对文章的总结。且出现了和对epub总结一样的问题，额外联想了一些内容，在最后一段中出现了大量下一章的内容，这显然不是我们在文章总结中所希望看到的。\npdf - 零一万物 第六链主要讨论了复杂网络中的分布规律，特别是幂律分布。这一概念起源于帕累托提出的80/20定律，即在许多情况下，约80%的效果是由约20%的原因产生的。在网络科学中，幂律分布表明网络中的节点连接度分布是不均匀的，少数节点（即枢纽节点）拥有大量的连接，而大多数节点的连接数则相对较少。这种分布方式对于理解网络的结构和行为非常重要，因为它揭示了网络中连接模式的普遍规律，以及这些规律如何影响网络的稳定性和传播动力学。\n观点错误，幂律分布并不是起源于80/20定律。且概括不全面，缺少要点。\npdf - 腾讯元宝 第六链主要探讨了复杂网络中的幂律分布现象，解释了幂律在网络中的普遍性和重要性，并提出了无尺度网络模型。以下是主要内容：\n幂律分布的普遍性：幂律分布不仅在万维网和好莱坞演员网络中出现，还在许多其他领域（如细胞网络、食物链网络、互联网等）中普遍存在。这种分布揭示了网络中少数枢纽节点的重要性。 无尺度网络模型：巴拉巴西和雷卡·阿尔伯特提出了一个无尺度网络模型，解释了幂律分布的来源。该模型通过“复制-连接”操作生成具有层次化聚团性的网络，展示了无尺度网络和模块化网络的融合。 枢纽节点的作用：枢纽节点在网络中扮演着关键角色，它们连接了大量其他节点，使得网络具有小世界特性。枢纽节点的存在使得网络在面对局部故障时更具健壮性，但也更容易受到攻击。 模块化与无尺度网络的结合：研究表明，许多真实网络不仅是无尺度的，还具有模块化特性。这种结合使得网络在保持整体连通性的同时，也能在局部区域内进行高效的组织和运作。 存在非本章的内容，如“枢纽节点的存在使得网络更容易受到攻击”和“真实网络具有模块化特性”。显然没有很好的分割各个章节。\n仅给出第六链部分的pdf文件，总结第六链 pdf - ChatGPT - 6’only 你上传的文件提到了关于复杂网络和幂律分布的内容，重点包括以下几个方面：\n幂律分布的特点：幂律分布是指很多小事件与少数重大事件共存的现象。该分布在现实中没有峰值，呈现出一种不断递减的曲线。这种现象在许多领域都有应用，例如互联网、社会经济不平等以及自然现象等。 帕累托与80/20定律：帕累托最初发现经济中的不平等现象，用他的经验观察指出80%的财富掌握在20%的人手中。这一原则后来被扩展为管理学中的80/20定律，适用于众多领域，例如客户服务、工作效率等。 无尺度网络与枢纽节点：无尺度网络是指遵循幂律度分布的网络，这种网络的特点是大多数节点连接较少，而少数枢纽节点连接很多。在这种结构中，网络的连通性和稳定性主要依赖于这些枢纽节点。 有序与无序的涌现：通过对物质相变的研究，物理学家发现了从无序到有序的自然转变过程中，幂律往往标志着从混沌到有序的过渡。这种现象不仅仅适用于物理系统，也适用于复杂网络等许多其他领域。 总结来说，幂律和无尺度网络揭示了自然界和社会系统中普遍存在的一种秩序，它们解释了从无序到有序的转变，以及少数事件对整体系统的深远影响。这些规律为理解复杂系统提供了重要的理论基础。\n完美！\npdf - 通义千问 - 6‘only 这本书中提到的幂律和无尺度网络是理解复杂系统的关键概念。以下是这些概念的核心要点总结：\n幂律分布：这是一种没有峰值且不断递减的分布，它描述了大量微小事件与少数重大事件共存的情况。例如，在一个假设星球上，如果居民身高遵循幂律分布，那么大多数人的身高会非常矮，但也会存在极少数几百米高的巨人。\n无尺度网络：这种网络的特点是其节点度数（即链接数量）遵循幂律分布。在这样的网络里，大部分节点只有很少几个链接，而少数枢纽节点拥有大量的链接。无尺度网络的结构类似于航空交通系统，其中许多小机场通过少数主要交通枢纽连接在一起。\n帕累托定律（80/20定律）：这个原则表明，一小部分因素通常会产生大部分结果。比如，80%的利润可能来自20%的员工；或者80%的土地被20%的人口所占有。尽管80/20法则有多种应用，但它并不适用于所有情况，而是特定系统中的特征。\n幂律在网络中的意义：当研究者发现万维网上的网页链接也遵循幂律时，这揭示了真实网络远非随机，而是具有某种内在秩序。这意味着网络中有重要的组织规则在起作用，特别是那些高度连接的枢纽节点对整个网络的稳定性、动态行为以及健壮性有着决定性的影响。\n自组织与涌现现象：书中还探讨了从无序到有序转变的现象，如水结冰或磁体形成的过程。这些相变展示了如何从个体单元间的简单相互作用中涌现出复杂的集体行为，这是理解和分析复杂系统的另一个关键方面。\n综上所述，幂律和无尺度网络的概念帮助我们理解了复杂系统背后的规律性和自组织特性，并强调了在看似混沌的环境中存在的潜在秩序。\n要点总结完美，但最后的综述偏离了文章主旨。\npdf - 零一万物 - 6’only 本文讨论了复杂网络中的幂律分布，这是一种没有峰值、不断递减的曲线，其中大量微小事件与少数重大事件并存。无尺度网络遵循幂律度分布，其中大多数节点只有少数链接，通过少数高度连接的枢纽节点连接在一起。帕累托的80/20定律是幂律分布的一个例子，其中80%的结果来自20%的原因。\n文章提到，40年前，埃尔德什和莱利将复杂网络视为随机系统，但幂律的出现表明这些网络实际上是自组织的。万维网上，网页链接数的分布遵循幂律，度指数接近2。这种分布意味着网络不是随机的，而是存在某种秩序。\n文章还讨论了相变，即物质从无序到有序的转变，其中也观察到了幂律。物理学家利奥·卡达诺夫和肯尼斯·威尔逊等人的工作揭示了相变中的普遍性，即不同系统在临界点附近表现出相似的行为，遵循幂律。\n最后，文章提出了问题：在网络中观察到的幂律意味着什么类型的转变？为什么枢纽节点出现在各种网络中？是否存在某种根本定律让不同的网络具有相同的普遍形式和形状？这些问题表明，尽管我们已经知道枢纽节点和幂律分布是自组织和有序的标志，但产生这些现象的机制仍然是一个谜。\n逻辑混乱，重点不突出，总结性不强。\npdf - 腾讯元宝 - 6‘only 这篇文章探讨了幂律分布及其在复杂网络中的应用，特别是无尺度网络的特征和重要性。\n幂律分布的定义与特征：\n幂律分布的定义：幂律分布是一种没有峰值且不断递减的曲线，特征是大量微小事件和少数重大事件并存。 幂律分布的实例：例如，星球上居民的身高分布，大多数人都很矮，但偶尔会有几百米高的巨人。 幂律分布与钟形曲线的区别：钟形曲线有明显的峰值，而幂律分布没有峰值，尾部衰减得更慢，允许“罕见事件”的存在。 无尺度网络的概念：\n无尺度网络的定义：无尺度网络是遵循幂律度分布的网络，大多数节点只有少数几个链接，通过少数高度连接的枢纽节点连接。 无尺度网络的视觉形象：类似于航空交通系统，很多小机场通过少数几个主要交通枢纽连接。 无尺度网络与随机网络的对比：随机网络大多数节点拥有相同的链接数，而无尺度网络有少数枢纽节点拥有大量链接。 帕累托与80/20定律：\n帕累托的生平与背景：意大利经济学家，曾从事铁路工程，后致力于经济学研究。 帕累托的观察与定律：发现80%的财富由20%的人口占有，提出了著名的80/20定律。 80/20定律的应用与扩展：广泛应用于管理学、社会学等领域，描述了大多数情况下，少量因素决定了大部分结果的现象。 幂律分布与度指数：\n幂律分布的数学表达：幂律分布可以用幂函数表示，每个幂律都有一个独一无二的幂指数。 万维网的幂律分布：网页链接数的分布遵循幂律，度指数接近2。 其他复杂网络的幂律分布：如好莱坞演员网络、细胞内部网络等，均遵循幂律分布。 幂律网络的特性与影响：\n幂律网络的不均匀性：大多数节点只有少数链接，枢纽节点拥有大量链接，保证了网络的连通性。 幂律网络的无尺度特性：没有特征节点，节点间存在连续的层级结构。 枢纽节点的重要性：枢纽节点决定了网络的结构稳定性、动态行为、健壮性、容错性和故障容忍性。 幂律分布的普遍性与自组织：\n幂律分布的普遍性：在自然界和复杂系统中广泛存在，如液体结冰、磁体涌现等。 相变与幂律分布：临界点附近，系统从无序到有序的相变过程中，幂律分布起着关键作用。 重整化理论：由肯尼斯·威尔逊提出，解释了幂律分布的数学基础，揭示了从无序到有序的转变机制。 幂律分布的未来研究方向：\n枢纽节点生成机制的研究：尚未完全解决，需要进一步探索。 复杂网络的临界点研究：研究网络为何处于临界点并展现无尺度行为。 普遍网络定律的探索：寻找不同网络具有相同普遍形式和形状的根本定律。 总的来说，这篇文章详细介绍了幂律分布及其在复杂网络中的应用，特别是无尺度网络的特征和重要性，展示了幂律分布在不同领域中的普遍性和深远影响。\n要点全面，但是冗余信息过多，总结性不强。\n小结 将整本书上传给大模型并要求总结特定章节时，部分大模型会出现“章节划分不清晰”的问题。而仅上传特定章节让其总结，效果显著提高。\n四个大模型均可通过进一步提示扩写摘要，但大致内容没有变化。\n在所评测的四个大模型中，ChatGPT \u0026gt; 通义千问 \u0026gt; 腾讯元宝 \u0026gt; 零一万物。\n四、文本理解能力 仅给出第六链部分的文件，基于我自己提出的问题比较四个大模型的文本理解能力。\nQ1：幂律分布和钟形分布的区别 ChatGPT 根据你上传的文件，幂律分布和钟形分布之间的主要区别如下：\n形状和分布特征：\n幂律分布：是一条没有峰值、不断递减的曲线，表示大多数事件非常小，少数事件非常大。幂律分布允许极端事件（如巨大的枢纽节点）存在，通常在复杂网络中广泛出现。 钟形分布（正态分布）：有一个明显的峰值，表示大多数事件集中在平均值附近，偏离平均值的事件相对较少。钟形分布常见于自然界的随机现象，如人的身高、体重等。 尾部衰减：\n幂律分布：尾部衰减较慢，意味着极端大事件的发生虽然少见，但仍可能出现。比如，在网络中少数枢纽节点拥有大量连接。 钟形分布：尾部衰减非常快，极端事件几乎不会出现。它表明系统中的大多数事件会集中在某个范围内，极端偏离的现象极为罕见。 应用场景：\n幂律分布：适用于复杂系统，如互联网节点、社交网络、科学家之间的引用关系等，反映了大多数节点只有少数连接，而少数枢纽节点连接非常多。 钟形分布：适用于随机现象或系统，如大气分子的速度分布、人类的智商分布等。 总结：幂律分布强调少数重大事件对系统的显著影响，而钟形分布强调事件的集中性和一致性，极端事件在钟形分布中非常少见。\n观点正确，回答全面，逻辑性强。\n通义千问 幂律分布和钟形分布（也称为正态分布或高斯分布）在形状和特性上有显著的区别：\n形状上的区别：\n钟形分布：这种分布有一个明显的峰，大多数数据点集中在平均值附近，随着远离平均值，出现的数据点数量迅速减少。它呈现出对称的钟形曲线。 幂律分布：幂律分布没有明显的峰，而是呈现出一条不断递减的曲线。这意味着有大量微小事件的存在，同时伴随着少数非常重大的事件。 尾部行为：\n钟形分布：其尾部衰减得非常快，偏离平均值较远的数据点极为罕见。这表明极端事件的发生概率极低。 幂律分布：幂律分布的尾部衰减速度慢得多，允许存在“罕见事件”。例如，在一个假设的星球上，如果居民身高遵循幂律分布，那么虽然大多数人很矮，但偶尔看到一个几百米高的巨人也不会让人感到特别惊讶。 数学表达：\n钟形分布：可以用正态分布函数来描述，具有明确的均值和方差。 幂律分布：通常用幂函数来表示，形式为 $N(k) \\sim k^{-\\gamma}$，其中 \\(k\\) 是变量，\\(N(k)\\) 是该变量取值 \\(k\\) 的频率，而 $\\gamma$ 是度指数。不同的系统会有不同的 $\\gamma$ 值。 实际应用中的意义：\n钟形分布：适用于很多自然现象，如人类的身高、智商等，这些量通常围绕着某个中心值波动，并且极端值很少见。 幂律分布：则常见于复杂网络中，比如网页链接数、社交网络中的好友数等，说明了网络中存在少量高度连接的节点（枢纽节点），它们对于整个网络结构至关重要。 简而言之，钟形分布强调的是数据的集中趋势，而幂律分布则揭示了数据中存在的广泛差异性和极端事件的可能性。这两种分布反映了自然界和社会现象中不同类型的数据模式。\n完美！逻辑和ChatGPT很像，但是多出了数学表达部分。\n零一万物 幂律分布和钟形分布的主要区别在于它们在分布尾部的行为。钟形分布，如正态分布，在尾部呈现出指数衰减，这意味着极端事件发生的概率非常低。相比之下，幂律分布在尾部的衰减要慢得多，这允许罕见事件（如枢纽节点）的存在。在钟形分布中，极端事件几乎不可能发生，而在幂律分布中，虽然罕见事件发生的概率也很低，但它们的存在是分布的一个显著特征。\n“主要区别在于它们在分布尾部的行为”这一观点并不准确，缺乏逻辑性。\n腾讯元宝 根据文档内容，幂律分布和钟形分布在分布的尾部存在重要的定性差异：\n尾部衰减速度：\n钟形分布：尾部的指数衰减速度非常快。这意味着偏离平均值的节点（如具有极多或极少链接的节点）非常罕见。 幂律分布：尾部的衰减速度较慢。这意味着在幂律分布中，存在一些“罕见事件”，即具有极多链接的枢纽节点。 枢纽节点的存在：\n钟形分布：由于尾部快速衰减，枢纽节点几乎不存在。大多数节点的链接数都接近平均值。 幂律分布：由于尾部衰减较慢，枢纽节点可以存在。这些枢纽节点拥有大量链接，使得网络具有高度的连通性。 分布形状：\n钟形分布：呈现出一个明显的峰值，表明大多数节点的链接数集中在平均值附近。 幂律分布：没有明显的峰值，呈现不断递减的曲线，表明大多数节点的链接数较少，但存在少数节点拥有非常多的链接。 总结来说，幂律分布和钟形分布的主要区别在于尾部的衰减速度和枢纽节点的存在与否。钟形分布的尾部快速衰减，导致枢纽节点不存在；而幂律分布的尾部衰减较慢，允许枢纽节点的存在。\n我个人认为，在幂律分布和钟形分布的差别中不应该出现“枢纽节点”，因为枢纽节点是具有幂律特性的网络中的一个具体现象，而不是两种分布的差异所在。\n对于Q1，通义千问 \u0026gt; ChatGPT \u0026gt; 腾讯元宝 \u0026gt; 零一万物\nQ2：什么是度指数 ChatGPT 根据文件，度指数是用于描述复杂网络中节点的链接数（度数）分布的一种参数，通常与幂律分布相关。\n具体来说，度指数是幂律分布公式中的指数参数，用来衡量网络中节点的链接数是如何分布的。例如，对于一个网络，具有 \\( k \\) 个链接的节点数 \\( N(k) \\) 遵循幂律分布，表达式为：$ N(k) \\sim k^{-\\gamma} $其中，γ（度指数） 描述了链接数分布的衰减速率。度指数越小，表示网络中有更多节点拥有大量链接；度指数越大，表示大部分节点的链接数较少，而少数枢纽节点拥有非常多的链接。\n在万维网的研究中，导入链接数的分布度指数大约为 2，而导出链接的分布度指数略大一些，表明不同网页之间的链接并不均匀，大多数网页有少量链接，而少数网页有大量链接。\n用词准确，回答简介易懂，没有缺少要点。\n通义千问 度指数是幂律分布中的一个关键参数，它描述了网络中节点的链接数（即度）是如何分布的。在数学上，如果一个网络的节点度数遵循幂律分布，那么可以表示为 $N(k) \\sim k^{-\\gamma}$，这里的 \\(k\\) 表示节点的度数，\\(N(k)\\) 表示具有 \\(k\\) 个链接的节点数量，而 $ \\gamma $ 就是度指数。\n度指数 $ \\gamma $ 的值决定了网络中不同度数节点的数量比例。具体来说：\n当 $ \\gamma $接近2时，意味着非常流行的节点（拥有大量链接的节点）相对较多。 如果 $ \\gamma $ 稍微大一些，比如接近3或更大，则说明非常流行的节点较少，大多数节点只有少量链接。 通过度指数，我们可以了解相对于不流行的网页，到底有多少非常流行的网页。在网络分析中，度指数通常用来衡量网络的异质性，以及识别出那些对网络连通性和稳定性起着关键作用的高度连接节点（枢纽节点）。例如，在万维网的研究中发现，网页的导入链接数和导出链接数都遵循幂律分布，其中导入链接的度指数接近2，而导出链接的度指数则稍微大一些。这些发现表明，尽管大部分网页只有少量链接，但少数网页却拥有大量的链接，这构成了无尺度网络的特征。\n基本和ChatGPT打平，用词稍微有点冗余，不够简洁，但无伤大雅。\n零一万物 度指数是指在网络中，节点连接度的分布遵循幂律分布时的幂指数。它表征了网络中节点连接度分布的形状，即有多少节点拥有多少连接。度指数可以通过在双对数坐标系下拟合节点连接度的直方图来确定，直线的斜率即为度指数。在万维网上，度指数接近2，这意味着网页的导入链接数的分布遵循幂律，且大多数网页只有少数链接，而少数枢纽网页则拥有非常多的链接。\n观点有误，度指数并非代表有多少节点拥有多少连接，缺少要点，缺少数学公式。\n腾讯元宝 根据文档内容，度指数是指幂律分布中的一个参数，用来描述网络中度（即节点的连接数）的分布情况。具体来说，度指数决定了幂律分布的具体形式。在网络科学中，度指数通常表示为γ，用来描述节点连接数的分布。文档中提到：\n每一个幂律都有一个独一无二的幂指数。通过幂指数我们可以得知，相对于那些不流行的网页，到底有多少非常流行的网页。在网络中，幂律可用于描述度的分布，而幂指数通常被称为度指数。\n例如，文档中提到网页的导入链接数的分布遵循幂律，度指数接近2；导出链接的度指数稍微大一些，大约为2.5。这意味着，如果有k个导入链接的网页数目N(k)遵循幂律分布，则可以表示为：\n$ N(k) \\sim k^{-\\gamma} $\n其中，γ就是度指数。在文档中提到的具体数值中，导入链接的度指数γ接近2，导出链接的度指数γ约为2.5。\n回答没有问题，但引用显得有些多余，逻辑也不够清晰。\n对于Q2，ChatGPT = 通义千问 \u0026gt; 腾讯元宝 \u0026gt; 零一万物\nQ3：互联网中的幂律是如何被发现的 ChatGPT 根据文件，互联网中的幂律分布是通过对万维网结构的分析而被发现的。发现过程如下：\n最初的预期：研究者最初预计万维网是一个随机网络，网页之间的链接数应遵循类似于钟形曲线的单峰分布。这意味着大多数网页的链接数相差不大，且没有明显的极端现象。\n实际发现：当郑浩雄（研究者）设计万维网采集机器人来分析网络时，采集到的数据表明，万维网上的链接数分布并不符合钟形分布。相反，很多网页只有少量链接，而少数网页拥有大量链接（枢纽节点）。这种分布与预期大相径庭。\n幂律分布的确认：通过将网络节点的链接数进行双对数坐标图绘制，研究者发现节点的连接度分布遵循幂律分布。这意味着，网页的链接数按照幂律的方式衰减：大多数节点只有少量链接，但少数枢纽节点拥有非常多的链接。\n结果的意义：这一发现表明，万维网并不是一个随机网络，而是一个无尺度网络（幂律分布的网络），其中少数枢纽节点在网络的连通性和结构中扮演着重要角色。研究者进一步观察到，其他复杂网络（如好莱坞演员网络、科学家引用网络等）也呈现出类似的幂律分布。\n通过这一过程，研究者首次确认了万维网的链接数遵循幂律分布，从而揭示了互联网背后复杂的网络结构。\n要点没有缺失，逻辑清晰，标准答案！\n通义千问 互联网中的幂律是通过研究网页之间的链接结构而被发现的。具体来说，当科学家们开始使用网络爬虫（微型搜索引擎）来探索万维网的结构时，他们原本预期会看到类似于随机网络的单峰分布，即大多数网页具有相似数量的链接。然而，实际观察到的结果却与这一预期大相径庭。\n研究人员注意到，在万维网中：\n许多节点（网页）只有少量链接。 一些枢纽节点（少数非常流行的网页）拥有大量的链接。 这种模式在双对数坐标系下进行拟合时，显示出一个令人惊讶的现象：网页链接数的分布严格遵循被称为幂律的数学表达式。这意味着，对于具有 \\(k\\) 个导入链接的网页数目 \\(N(k)\\)，其分布可以用公式 $ N(k) \\sim k^{-\\gamma} $ 来描述，其中 $\\gamma$ 是度指数，大约为2.1；而对于导出链接数的分布，度指数则稍大一些，约为2.5。\n这些发现表明，万维网并不是一个随机网络，而是展现出了一种全新的秩序——无尺度网络。在这个网络中，大部分节点仅有少数几个链接，但少数高度连接的枢纽节点确保了整个网络的连通性。这样的网络结构具有不同寻常的一致性和美感，并且揭示了复杂网络背后的自组织特性。此外，它也预示着存在一些重要的规则支配着网络的演化过程。这个发现改变了人们对网络结构的理解，并推动了进一步的研究，以探究其他复杂系统如好莱坞演员网络、科学合作网络等是否也遵循类似的规律。\n要点完整，但是逻辑不够清晰，介绍“幂律”有点多余。\n零一万物 互联网中的幂律是通过对万维网上网页链接的分布进行研究而被发现的。研究人员设计了微型搜索引擎（也称为网络爬虫或机器人），用来收集和分析网页之间的链接。他们发现，网页的导入链接数遵循幂律分布，度指数接近2。这意味着网页链接的分布并不是随机的，而是呈现出一种特定的模式，其中大多数网页只有少量链接，而少数网页（枢纽节点）则拥有非常多的链接。这种分布与传统的钟形曲线不同，它表明了网络的自组织特性，即网络不是随机生成的，而是由某种规则支配的。\n要点完整，逻辑清晰，但是不够详细，语言描述上有待加强。\n腾讯元宝 根据文档内容，互联网中的幂律是通过以下步骤和实验被发现的：\n初步观察：郑浩雄在设计万维网采集机器人时，原本预期网页之间的连接是随机的，类似于单峰分布，即大多数文档的流行度相似。\n实际数据采集：机器人带回的网络数据中，发现许多节点只有少量链接，而一些枢纽节点却拥有非常多的链接。\n数据分析：在双对数坐标系下拟合节点连接度的直方图时，发现网页链接数的分布严格遵循幂律的数学表达式。\n幂律特征：幂律分布没有峰，是一条不断递减的曲线，这意味着大量微小事件和少数非常重大的事件并存。这与自然界中大多数量遵循的钟形曲线（单峰分布）有显著差异。\n广泛适用性：除了万维网，幂律分布也在其他复杂网络中被发现，如好莱坞演员网络、细胞内部网络、物理期刊引用网络等。这些发现表明，幂律分布是一种普遍存在于复杂网络中的现象。\n科学研究：科学家们进一步研究了幂律分布的数学特性和物理意义，发现幂律分布通常标志着从无序到有序的过渡，是复杂系统自组织的一种表现。\n理论发展：为了理解幂律分布背后的机制，物理学家提出了重整化群理论，由肯尼斯·威尔逊等人发展，为相变和临界现象提供了统一的解释框架。\n通过这些步骤，科学家们逐渐认识到幂律分布是描述复杂网络，特别是互联网中节点连接度分布的关键数学工具。\n存在大量冗余信息，逻辑混乱。\n对于Q3，ChatGPT \u0026gt; 零一万物 \u0026gt; 通义千问 \u0026gt; 腾讯元宝\nQ4：具有幂律度分布的网络为什么被称为“无尺度网络” ChatGPT 根据文件，具有幂律度分布的网络之所以被称为“无尺度网络”，是因为在这些网络中没有一个特定的特征节点或特征尺度 来描述整个网络的结构。\n具体来说：\n度分布没有特征尺度：在无尺度网络中，节点的连接数（度数）并不集中在一个特定的值范围内。相反，连接数分布遵循幂律，大多数节点拥有少量链接，而少数枢纽节点拥有大量链接。这种分布没有峰值或明显的平均值，因此无法用单一的度数来概括所有节点。\n层级结构：无尺度网络展现出一种连续的层级结构，从少数具有大量链接的枢纽节点到大量只有少量链接的小节点。由于没有统一的尺度或平均链接数，网络的整体结构是通过这种层级组织维持的，而不是通过均匀分布的节点。\n幂律分布的性质：幂律分布的尾部衰减较慢，允许极少数节点拥有非常多的链接（即枢纽节点），这与随机网络中大多数节点拥有相似链接数的情况不同。无尺度网络的连通性和稳定性主要依赖这些枢纽节点，而随机网络的节点连接度具有特定的尺度（通常为平均连接数）。\n因此，具有幂律度分布的网络被称为“无尺度网络”，因为它们没有固定的特征节点或平均连接数，表现出一种从大量小节点到少数枢纽节点的层级结构。\n要点完整，详略得当，标准答案！\n通义千问 具有幂律度分布的网络被称为“无尺度网络”，主要是因为这种网络中不存在一个典型的或者特征性的节点度数（即链接数量）。在传统的随机网络中，节点的度分布呈现出单峰曲线，大多数节点拥有接近平均值的链接数，偏离这个平均值的情况非常少见。这样的网络有一个明确的特征尺度，可以用平均节点来代表。\n相比之下，在遵循幂律度分布的网络里，绝大多数节点仅有少数几个链接，而同时存在少量高度连接的枢纽节点，每个枢纽节点拥有大量的链接。由于这些枢纽节点的存在，网络中的节点度数范围可以从很小延伸到非常大，形成了一个连续的层级结构，从极少数的大枢纽节点到众多的小节点。因此，在这种网络中，无法找到一个能够代表所有节点特性的单一尺度或特征节点。\n具体来说：\n没有特征尺度：幂律分布缺乏钟形曲线那样的峰值，这表明在网络中找不到一个可以作为“典型”或“平均”的节点。 连续的层级结构：从最大的枢纽节点开始，随后是稍微小一些的枢纽节点，接着是一系列更小的节点，最后是大量的小节点，形成了一个平滑过渡的层级结构。 网络连通性依赖于枢纽节点：小节点拥有的少数链接不足以保证整个网络完全连通，而是由少数高度连接的枢纽节点确保了网络的整体连通性。 由于上述特性，研究者将这类网络称为“无尺度网络”，强调了它们与传统随机网络在结构上的根本不同。无尺度网络的概念揭示了自然界和人类社会中许多复杂系统的共通规律，并且对理解这些系统的稳定性、动态行为以及故障容忍性等方面提供了重要的视角。\n和ChatGPT的逻辑很相似，但是语言描述上不够简洁。\n零一万物 具有幂律度分布的网络被称为“无尺度网络”是因为在这种网络中，节点的连接度分布遵循幂律，这意味着网络中不存在特征尺度。在无尺度网络中，大多数节点只有少数连接，而少数枢纽节点拥有大量连接。这种分布没有峰值，衰减速度比钟形分布慢，允许罕见但高度连接的枢纽节点存在。由于没有特征尺度，网络的结构和动态行为不能通过单一的尺度来描述，因此被命名为“无尺度网络”。\n要点不够清晰，逻辑混乱。\n腾讯元宝 根据文档内容，具有幂律度分布的网络被称为“无尺度网络”的原因如下：\n幂律分布的特性：幂律分布是一种没有峰值的分布，其特点是大量微小事件和少数非常重大的事件并存。这与钟形分布（如正态分布）不同，后者有一个明显的峰值，表明大多数事件集中在平均值附近。 网络结构的特殊性：在无尺度网络中，大多数节点只有少数几个链接，而少数枢纽节点拥有非常多的链接。这种结构使得网络在形状上类似于航空交通系统，其中很多小机场通过少数几个主要的交通枢纽连接在一起。 无尺度特性：幂律分布的无尺度特性意味着网络中没有特征尺度或特征节点。在随机网络中，分布的峰值意味着绝大多数节点拥有同样数目的链接，而在无尺度网络中，幂律分布没有峰值，表明节点间存在连续的层级结构，从少数枢纽节点到为数众多的小节点。 枢纽节点的决定性作用：无尺度网络中的枢纽节点对网络的连通性和整体结构起着决定性作用。这些枢纽节点的存在使得网络免于瓦解，并且它们的数量和分布遵循幂律分布。 放弃尺度或特征节点的概念：由于幂律分布没有峰值，网络中不存在固有的尺度或特征节点。这意味着在无尺度网络中，无法找到一个能够代表所有节点特性的节点，这与随机网络和钟形分布的网络形成鲜明对比。 因此，具有幂律度分布的网络被称为“无尺度网络”，是因为它们展示了一种没有特征尺度或特征节点的网络结构，其中枢纽节点对网络的性质起着决定性作用，并且节点的连接度分布遵循幂律分布。\n信息冗余，一些要点表达的是同一个意思，逻辑有点混乱。\n对于Q4，ChatGPT \u0026gt; 通义千问 \u0026gt; 零一万物 \u0026gt; 腾讯元宝\n小结 根据文件回答问题，ChatGPT综合表现最优，回答直击要点，逻辑清晰，基本可以看作标准答案；通义千问表现也很好，但是在语言的简洁性和逻辑性上略输ChatGPT；腾讯元宝表现较差，出现大量冗余信息；零一万物表现最差，会出现错误答案，且回答不够详细。\n五、文本输出能力 ChatGPT 通义千问 零一万物 腾讯元宝 PPT ✗ ✓ ✓ ✗ Markdown ✓ ✓ ✓ ✓ 思维导图 ✓ ✓ ✗ ✓ 仅通义千问和零一万物可以输出ppt，其中仅通义千问可以根据pdf文件制作ppt，零一万物只能通过word和ppt格式文件制作ppt。\n仅通义千问和腾讯元宝有专门的阅读文件模式且能输出思维导图，其他大模型仅能输出文字大纲。\n通义千问在阅读模式中提供了“导读”、“翻译”、“脑图”、“笔记”四个功能。其中思维导图是按“定义与特点”、“历史发展”、“未来研究方向”等方面划分层次。\n腾讯元宝在阅读模式中提供了“总结”、“精读”、“脑图”三个功能。思维导图按小标题划分层次。\n个人认为腾讯元宝的思维导图质量远大于通义千问。\n小结 通义千问完胜。\n六、多知识点层次结构关联 ChatGPT\n根据你上传的文件内容，关于幂律分布、无尺度网络等相关知识的结构层次关联可以整理如下：\n幂律分布的基本概念\n幂律分布：指在复杂网络中，大多数节点有少量链接，少数节点拥有大量链接。其数学特征是一条不断递减的曲线，没有峰值。 关键词：大量微小事件、少数重大事件、递减曲线。 幂律分布与随机分布的区别\n幂律分布：允许极端事件（如大量链接的枢纽节点）存在，表现为尾部衰减慢。 钟形分布：大多数事件集中在平均值附近，尾部迅速衰减，极端事件极少。 幂律分布中的度指数\n度指数：幂律分布公式中的指数参数，反映网络中节点链接数的衰减速率。度指数小，表示更多节点拥有大量链接；度指数大，表示少数节点拥有大量链接。 幂律分布在互联网中的发现\n发现过程：研究者最初预计万维网的链接数分布是随机的，但通过数据分析发现，网页之间的链接数遵循幂律分布，揭示出互联网的复杂网络结构。 双对数坐标：幂律分布在双对数坐标系下呈现为线性，进一步证明了少数节点（枢纽节点）的重要性。 无尺度网络的定义与特点\n无尺度网络：具有幂律度分布的网络，因为没有明显的特征尺度而得名。即没有特征节点，节点的度数没有集中在某个值。 主要特点：少数枢纽节点连接大量小节点，网络的连通性和稳定性由枢纽节点维持。 无尺度网络与随机网络的对比\n随机网络：节点的链接数遵循钟形分布，节点间连接较为均匀，大多数节点拥有相似的链接数。 无尺度网络：节点的链接数遵循幂律分布，少数枢纽节点连接大量节点，枢纽节点是网络的核心。 幂律与复杂系统的涌现\n从无序到有序的涌现：幂律分布往往出现在复杂系统从无序向有序转变的过程中，如物质相变或网络结构的形成。 自组织与幂律：幂律分布是复杂网络自组织行为的表现，枢纽节点的形成和稳定性由这种自组织推动。 幂律分布在不同领域的应用\n互联网、科学家引用、好莱坞演员网络：这些网络都遵循幂律分布，表明复杂网络背后可能存在统一的数学规律。 经济学中的帕累托法则：80/20定律（帕累托法则）也是幂律分布的一种具体表现，少数资源（财富、影响力）掌握在少数人手中。 这套知识结构从基础概念到应用，逐步揭示了幂律分布在复杂网络中的作用，并通过无尺度网络的特点来展示其在现实中的应用场景，如互联网、社会网络等。\n覆盖全面，有对知识点的简单说明。个人认为前四个知识点划分在一起会更好。\n通义千问\n根据提供的内容，可以将知识点的结构层次关联整理如下：\n幂律与复杂网络\n幂律分布：描述了大量微小事件和少数非常重大事件并存的现象。 无尺度网络：遵循幂律度分布的网络，具有不均匀性，其中大多数节点只有少量链接，而少数枢纽节点拥有大量的链接。 帕累托原则（80/20定律）：描述了在很多领域中，大部分结果往往由相对较小比例的原因造成。 复杂网络特性\n网络中的节点和链接：节点代表个体或实体，链接表示它们之间的关系。 随机网络 vs 无尺度网络：随机网络节点间的连接是均匀的，而无尺度网络则存在高度连接的枢纽节点。 度指数：用于描述网络中恰好有k个链接的节点数遵循幂律的方式，不同的系统有不同的度指数。 从无序到有序的相变\n自发涌现：无序系统在特定条件下自发地形成有序结构。 相变的例子：如水结冰、金属磁化等现象。 关联长度：随着系统接近临界点，关联长度按照幂律增加，表明系统内部相关性的变化。 相变理论的发展\n卡达诺夫的尺度概念：提出在临界点附近应考虑原子群体的行为而不是单独的原子。 临界指数：描述相变过程中不同物理量的变化规律。 威尔逊的重整化理论：提供了一个统一的框架来解释临界现象，并预测临界指数。 幂律的意义\n描述自然和社会系统的自组织行为。 在万维网和其他复杂系统中的发现，揭示了一种新的秩序形式。 指出当系统经历相变时，幂律的出现是混沌向有序过渡的一个标志。 这些知识点之间通过数学模型和实验观察相互联系，共同构成了理解复杂系统行为的基础。从幂律分布到相变过程，再到对自然界和社会现象的广泛适用性，这些概念帮助我们洞察复杂网络背后的普遍规律。\n结构划分更合理，但是知识点归类有错误，“度指数”应该放在“幂律与复杂网络”。\n零一万物\n知识点的结构层次关联可以按照以下层次来组织：\n复杂网络的分布规律 幂律分布 无尺度网络 枢纽节点 随机网络与无尺度网络的区别 幂律分布的特性 大量微小事件和少数重大事件并存 没有峰值，不断递减的曲线 度指数和幂指数 无尺度网络的特点 大多数节点只有少数链接 少数枢纽节点拥有大量链接 网络的连通性由枢纽节点保证 相变理论与幂律的关系 从无序到有序的转变 自组织在相变中的作用 临界指数和幂律的关联 帕累托的80/20定律与幂律分布 少数事件或人产生大部分影响 收入不均衡现象 网络中的幂律现象 万维网上链接的分布 好莱坞演员网络 细胞内部网络 物理期刊引用数分布 幂律在不同系统中的普遍性 液体变成气体 铅变成超导体 不同系统中的高度相似性 幂律与自组织秩序 幂律作为自组织和有序的标志 复杂网络中的秩序和一致性 幂律的机制和网络的演化 产生枢纽节点和幂律分布的机制 网络是否处于从无序到有序的转变中 自然界中的网络构建 不同网络的普遍形式和形状 自然界如何织成这些网络 这个结构层次关联图展示了文档中提到的不同概念如何相互关联，以及它们在复杂网络理论中的位置。\n结构划分不合理，逻辑混乱，且缺少对知识点的简要概括。\n腾讯元宝\n复杂网络 幂律分布 定义：无峰，不断递减的曲线 特征：大量微小事件和少数非常重大的事件并存 例子：星球居民身高分布 无尺度网络 定义：遵循幂律度分布的网络 特征：大多数节点只有很少几个链接，通过少数几个高度连接的枢纽节点连接 例子：航空交通系统 帕累托与80/20定律 帕累托：意大利经济学家，提出80/20定律 80/20定律：大多数情况下，80%的效果来自20%的原因 应用：经济学、管理学、网络科学等 幂律分布与度指数 度指数：描述幂律分布的参数 万维网：导入链接数和导出链接数遵循幂律分布 不均匀性，幂律度分布网络的特性 随机网络与无尺度网络的对比 无尺度网络的不均匀特性 链接洞察 幂律分布迫使放弃尺度或特征节点的想法 无尺度网络中枢纽节点的重要性 幂律，复杂网络背后的规律 幂律在自然界和复杂网络中的普遍性 幂律标志着从无序到有序的过渡 自发涌现 水变成冰的相变现象 相变是从无序到有序的过程 有序如何从无序中涌现 相变点附近的临界现象 幂律在相变过程中的普遍性 从“随机”灌木丛到“自组织”舞台 卡达诺夫的尺度不变性概念 威尔逊的重整化理论 幂律无处不在 幂律在各种自然现象和复杂网络中的普遍存在 幂律作为自组织和有序的标志 完全是按照小标题划分的，出现“链接洞察”这样可笑的错误。\n小结 在多知识点层次结构关联方面，通义千问 \u0026gt; ChatGPT \u0026gt; 零一万物 \u0026gt; 腾讯混元\n七、AI知识点扩写 扩写“幂律分布”（书本外内容） ChatGPT\n幂律分布在复杂系统的研究中扮演着重要角色，它不仅在互联网、社交网络等现代网络结构中广泛存在，还与多种自然现象和社会现象密切相关。联系文章外的相关内容，幂律分布的研究不仅推动了网络科学的发展，也为其他学科（如经济学、物理学和生物学）提供了新的分析工具和理论框架。以下是基于文章外的扩展讨论：\n1. 幂律分布在社会现象中的应用 1.1 财富分配与经济学中的幂律 幂律分布与帕累托的80/20定律紧密相关，经济学中的收入和财富分布常常表现为幂律分布。例如：\n财富集中效应：在许多国家中，少数富人占据了大部分的财富，而大多数人仅拥有少量财富。这种不平等的财富分布在不同社会结构中普遍存在，正是帕累托定律的体现。研究表明，无论是全球富人群体，还是具体国家内部，财富的分布都呈现出幂律分布的特征。 公司规模与市场份额：企业规模（如员工数量或收入）往往也符合幂律分布。少数大型跨国公司（如苹果、亚马逊）主导市场，占据大部分份额，而大多数中小企业只占据少量市场。 1.2 犯罪与警务工作 幂律分布同样可以应用于犯罪现象分析。例如，少数罪犯可能贡献了大多数的犯罪行为。根据“20%的罪犯犯下了80%的犯罪”的规律，警务部门可以根据这一分布规律更有针对性地分配资源，从而提高社会治安的效率。\n2. 自然现象中的幂律分布 2.1 地震与自然灾害 在地质学中，地震的规模分布也是幂律分布的一个典型案例，即地震频率与震级大小呈反比关系。小地震频繁发生，而大地震则非常罕见，但其破坏性巨大。正如古登堡-里希特定律所描述，震级增加一级，地震的发生频率会减少大约10倍。这种分布模式有助于地质学家估算地震风险，提前做好防灾预案。\n2.2 城市规模与人口分布 城市人口的分布也符合幂律分布。Zipf定律指出，一个国家或地区的城市规模与城市排名成反比关系。例如，在美国，纽约是最大的城市，洛杉矶作为第二大城市的人口大约是纽约的1/2，芝加哥作为第三大城市的人口大约是洛杉矶的1/2。这种规律在世界范围内广泛存在，揭示了城市发展的内在动力和结构规律。\n2.3 物种分布与生态学 在生态系统中，物种的种群数量也常常呈幂律分布。大多数物种的个体数量较少，而少数物种（如某些主导物种）个体数量较多。这种分布特征揭示了生态系统中的生物多样性和食物链的稳定性，也帮助科学家预测濒危物种和生态系统的动态变化。\n3. 幂律分布在物理与技术领域的应用 3.1 幂律与物理系统的相变 在物理学中，幂律分布常出现在相变现象的临界点附近。例如，当物质从液态转变为气态或从无序状态转变为有序状态时，系统中的某些量（如簇的大小、磁性强度等）会表现出幂律分布。特别是在临界点处，物质的性质不再依赖于其微观细节，而是呈现出全局的集体行为，物理学家通过幂律分布来描述这些系统的规模不变性和集体现象。\n3.2 互联网与网络拓扑结构 在网络科学中，互联网的链接分布是幂律分布的一个典型例子。互联网作为一个复杂网络，其节点（网站或服务器）的链接数遵循幂律分布，这意味着大多数节点（如个人网站、小型服务器）拥有较少的链接，而少数节点（如谷歌、脸书等）拥有大量链接，形成枢纽节点。这些枢纽节点决定了网络的稳定性和连通性。\n这种幂律分布也解释了互联网的健壮性和脆弱性：\n健壮性：网络对随机故障具有很强的抵抗力，即使一些普通节点失效，网络整体仍能保持连通。 脆弱性：如果少数枢纽节点遭到攻击或失效，整个网络可能迅速瓦解，连通性大大降低。 3.3 电力网络与技术系统 电力网络和技术基础设施中的负载分布也往往表现为幂律分布。少数变电站、发电厂可能承担了大部分的电力传输和生产，而大多数较小的节点只处理少量电力流。这种分布模式帮助工程师更好地理解系统的脆弱性，并设计出更高效的容错机制。\n4. 幂律分布与自组织现象 幂律分布在许多情况下与自组织现象密切相关。自组织是指系统内部的个体通过简单的局部规则，能够自发形成全局的有序结构，而不需要外部指令或中央控制。复杂网络、相变过程、以及经济系统的演化，都是自组织现象的典型例子。\n自组织临界性：许多复杂系统会自发地达到一种临界状态，在这种状态下，系统的行为呈现出幂律分布。这种现象被称为“自组织临界性”，比如雪崩、森林火灾等，这些系统可以在局部扰动下产生大规模连锁反应。 5. 幂律分布的研究进展与挑战 尽管幂律分布已经在许多领域得到了广泛应用，但仍有一些挑战存在：\n数据验证：现实中的数据是否严格符合幂律分布仍需谨慎验证。由于幂律的长尾效应，数据采样不足可能导致误判。 模型解释：虽然幂律分布揭示了系统的某些特性，但其背后的形成机制仍需进一步研究。如何通过简单的局部规则生成全局的幂律分布，仍是科学家们正在探索的问题。 实际应用：虽然幂律分布在理论上具有广泛应用，但如何利用这一规律来改善系统的设计和优化，是工程和应用领域的一个重要问题。 总之，幂律分布揭示了复杂系统中极端事件的重要性，联系了不同领域中个体行为与全局结构的关系。从互联网、社交网络到自然界中的地震和城市规模，幂律分布为我们提供了一种理解复杂现象的通用工具。在未来的研究中，进一步探索幂律分布的形成机制及其应用前景，将为复杂系统的理论发展和实际应用提供新的思路。\n重点叙述了幂律关系在其他领域的应用以及相关研究。内容非常详细。\n通义千问\n幂律分布是一种统计分布，它描述的是在很多自然和社会现象中，事件的大小与其发生的频率之间的一种特殊关系。这种分布的特点是少数非常大的事件与大量的小事件共存，并且这些事件的规模和它们出现的概率之间的关系遵循一个特定的数学表达式，即P(x) ∝ x^(-α)，其中P(x)是大于x的事件发生的概率，而α是一个正实数，被称为幂指数或度指数。\n幂律分布的普遍性\n幂律分布在自然界、社会经济系统、互联网、社交网络等多个领域都有广泛的应用。例如：\n自然灾害：地震的震级和发生频率、洪水的规模与发生频率等都呈现出幂律分布。 城市人口：城市的规模（如人口数量）通常遵循幂律分布，这表明大多数城市规模较小，但存在少量非常大的城市。 收入分配：财富分配不均的现象可以用幂律来描述，说明了极少数人拥有大部分财富的情况。 网站链接：网页间的链接数也呈现幂律分布，这意味着绝大多数网页只有少数链接，而少数网页则有大量链接。 社交媒体：用户的粉丝数量或者帖子的转发次数也可能遵循幂律分布。 幂律分布的意义\n揭示隐藏秩序：虽然表面上看这些系统似乎是混乱无序的，但幂律分布揭示了它们背后的有序性和一致性。 关键节点的重要性：在具有幂律分布特性的网络中，一些高度连接的关键节点（枢纽节点）对于整个系统的稳定性和连通性至关重要。 预测极端事件：理解幂律分布有助于更好地预测罕见但影响巨大的极端事件的发生概率，比如金融市场的崩盘或大规模传染病爆发。 幂律分布与自组织\n幂律分布往往出现在那些通过自我调节过程发展起来的复杂系统中。这些系统不是由外部力量设计出来的，而是通过内部各部分之间的相互作用逐步形成的。这样的自组织过程可以导致幂律分布的形成，因为系统会倾向于优化某些属性，从而使得某些特征比其他特征更加突出。\n幂律分布的挑战\n尽管幂律分布提供了一个强大的工具来分析和理解复杂系统，但在实际应用中也会遇到一些挑战，比如如何准确地识别数据是否符合幂律分布，以及如何解释幂律分布背后的具体机制。此外，在许多情况下，幂律分布可能只是对数据的一个近似描述，而非精确模型，因此需要结合具体情况和其他方法进行综合分析。\n总之，幂律分布为我们提供了理解自然界和社会现象的新视角，它帮助我们认识到即使是在看似随机的环境中，仍然存在着潜在的结构和规律。通过对幂律分布的研究，科学家们能够更好地认识世界的运作方式，并为解决现实世界的问题提供新的思路。\n其他领域的应用、意义和实际应用中的问题都有涉及，个人认为更加合理。\n零一万物\n幂律分布是一种特殊的概率分布，它在很多复杂的自然和社会现象中被观察到。这种分布的特点是没有明显的峰值，而是呈现出一种长尾分布，即大多数事件的规模很小，但偶尔会出现一些非常大的事件。幂律分布可以用一个简单的数学公式来描述，其中包含一个幂指数，这个指数决定了分布的形状。\n在文章中提到的万维网上，网页的链接数遵循幂律分布，这意味着大多数网页只有少数链接，而少数网页（枢纽节点）却拥有大量的链接。这种分布模式在很多其他网络中也存在，比如社交网络、生物网络和经济系统。\n文章外，幂律分布在许多领域都有应用。例如，在经济学中，帕累托法则（80/20法则）指出，20%的人口拥有80%的财富，这实际上是幂律分布的一个例子。在城市规划中，城市的大小和它们的排名也遵循幂律分布，这就是齐普夫定律。在地质学中，地震的规模和它们的频率也符合幂律分布，这意味着大地震虽然罕见，但它们的影响深远。\n此外，幂律分布在物理学中也很重要，特别是在相变理论中。当系统从无序状态转变为有序状态时，例如当物质从液体变成气体时，系统中的某些量会遵循幂律分布。这种分布表明系统正处于临界状态，即从一种状态转变为另一种状态的边缘。\n理解幂律分布对于预测和控制复杂系统的行为至关重要。例如，了解金融市场的幂律分布可以帮助投资者更好地管理风险。在公共卫生领域，了解疾病传播的幂律特性可以帮助政策制定者更有效地分配资源以应对疫情。\n总之，幂律分布是一个跨学科的概念，它在描述和理解复杂系统的行为方面发挥着关键作用。通过研究幂律分布，科学家们可以揭示隐藏在复杂现象背后的简单规律，从而为预测和控制这些现象提供有力的工具。\n没有层次划分，一大段文字不易阅读，侧重点也在于其他领域的应用。\n腾讯元宝\n幂律分布（Power Law Distribution）是一种在自然界和社会科学领域中广泛存在的概率分布现象。它描述了一种“长尾效应”，即在大量数据中，少数数据点占据了大部分的份额，而大多数数据点则相对较少。幂律分布在许多实际应用场景中都有体现，如城市人口分布、互联网网页链接、社交媒体关注度等。\n幂律分布的基本特征 无标度性：幂律分布的一个显著特点是无标度性，即数据的分布不受特定单位或尺度的影响。这意味着在不同尺度上观察数据时，其形态保持一致。\n长尾特性：在幂律分布中，尾部的数据点虽然数量少，但它们的总和可能占据整个分布的很大一部分。这种特性使得幂律分布与正态分布等其他常见的概率分布有显著区别。\n自相似性：幂律分布具有自相似性，即在不同的时间尺度或空间尺度上，数据的分布模式呈现出相似的结构。\n幂律分布的应用领域 社会科学：在社会科学研究中，幂律分布常用于分析社会网络、经济不平等、城市规模分布等问题。例如，城市人口往往遵循幂律分布，少数大城市聚集了大量人口，而众多小城市的人口则相对较少。\n网络科学：互联网中的网页链接、用户关注度等都表现出幂律分布的特点。搜索引擎算法如PageRank就是基于网页之间的链接关系，利用幂律分布的特性来确定网页的重要性。\n金融领域：金融市场中的价格波动、交易量等也常常服从幂律分布。这有助于理解极端事件（如金融危机）的发生概率及其影响。\n生物学与生态学：生物种群的大小、物种多样性以及生态系统中的能量流动等现象，也可以通过幂律分布来描述。\n幂律分布的形成机制 幂律分布的形成通常与以下几个因素有关：\n正反馈机制：当系统中存在正反馈循环时，小的优势会被不断放大，从而导致某些个体或事件在竞争中占据主导地位。\n网络效应：在复杂网络中，节点之间的连接往往遵循幂律分布。网络的生长和演化过程中，新节点更倾向于连接到已有较多连接的节点上。\n随机过程中的稀有事件：在某些随机过程中，虽然稀有事件发生的概率很低，但一旦发生，它们会产生深远的影响，进而影响整体的分布格局。\n幂律分布的统计检验与分析方法 为了验证数据是否符合幂律分布，研究者们通常采用以下几种方法：\n对数坐标图：将数据取对数后绘制在双对数坐标图上，如果数据点近似呈一条直线，则表明数据服从幂律分布。\n最大似然估计法：这是一种更为精确的参数估计方法，可用于确定幂律分布的具体参数。\n拟合优度检验：通过比较实际数据与理论幂律分布的拟合程度，来评估幂律分布的适用性。\n总之，幂律分布作为一种普遍存在的自然现象和社会现象，为我们理解和解释复杂系统中的各种不平衡和异质性提供了重要的理论工具和分析框架。\n最佳回答，涉及基本特征、应用领域、形成机制和分析方法。\n小结 在这一回合，腾讯元宝 \u0026gt; 通义千问 \u0026gt; ChatGPT \u0026gt; 零一万物\n八、AI知识点网搜图 仅腾讯元宝能直接给出网搜图，其他模型均只能给出图片建议和关键字\n![](C:\\Users\\13905\\Pictures\\Screenshots\\屏幕截图 2024-10-06 210638.png)\n腾讯元宝给出的网搜图\n九、AI知识点文生图 “在相变点，系统在两个状态间面临的抉择，就像站在山脊上的登山者要选择从哪一边下山一样。在没有做出决定之前，系统通常左右摇摆，这种摇摆在临界点附近达到极致。”根据这段文字生成图片\nChatGPT\n![](C:\\Users\\13905\\Downloads\\DALL·E 2024-10-06 21.28.40 - A metaphorical image representing a phase transition at a critical point, showing a mountain ridge with a climber at the top. The climber stands on th.webp)\n完全写实风格，山的两边对比明显，符合文字的主题。\n通义千问\n偏写实风格，山的两边对比明显，符合文字的主题，和我想象的差不多，excellent！\n零一万物\n无法生成图片\n腾讯元宝\n![](C:\\Users\\13905\\Pictures\\Screenshots\\屏幕截图 2024-10-06 211736.png)\n给出四个图片，卡通画风，大致描绘出了场景，但和文字不搭。\n十、总结 通过本次调研可得到以下结论\n排名 文本阅读能力 通义千问 \u0026raquo; 腾讯元宝 \u0026gt; ChatGPT \u0026gt; 零一万物 文本摘要能力 ChatGPT \u0026gt; 通义千问 \u0026gt; 腾讯元宝 \u0026gt; 零一万物 文本理解能力 ChatGPT \u0026gt; 通义千问 \u0026gt; 腾讯元宝 \u0026gt; 零一万物 文本输出能力 通义千问完胜 多知识点层次结构关联 通义千问 \u0026gt; ChatGPT \u0026gt; 零一万物 \u0026gt; 腾讯混元 AI知识点扩写 腾讯元宝 \u0026gt; 通义千问 \u0026gt; ChatGPT \u0026gt; 零一万物 AI知识点网搜图 仅腾讯元宝能做到 AI知识点文生图 通义千问 ≈ ChatGPT \u0026gt; 腾讯元宝，零一万物无此功能 输入方式：对于总结特定章节，特定章节输入 \u0026gt; 整本书输入，文件阅读模式 \u0026gt; 对话模式 回答质量/可靠性：ChatGPT \u0026gt; 通义千问 \u0026gt; 腾讯元宝 \u0026gt; 零一万物 功能性：通义千问 \u0026raquo; 腾讯元宝 \u0026gt; 零一万物 \u0026gt; ChatGPT 综合能力：通义千问 \u0026gt; ChatGPT \u0026gt; 腾讯元宝 \u0026gt; 零一万物 ","date":"2024-10-12T18:06:00Z","image":"https://lhy0424.top/p/%E7%A7%91%E7%A0%94%E8%AF%BE%E5%A0%82%E8%B0%83%E7%A0%94/llm_kykt_hu_e561db29f4d65dd8.png","permalink":"https://lhy0424.top/p/%E7%A7%91%E7%A0%94%E8%AF%BE%E5%A0%82%E8%B0%83%E7%A0%94/","title":"大模型调研——以《链接》第六链为例"},{"content":"有限状态机 表示有限个状态以及在这些状态之间的转移和动作等行为的数学统计模型。\n有限状态机（FSM）组成部分 State : 系统可能处于的状态。每个状态反映的是系统的某个模式或环节。有限状态机的状态是有限的。\nInput : 外部输入的信号，会影响状态的转换。\nOutput : 状态机在特定条件下输出的信号。\nTransitions : 系统根据状态转移函数从一个状态转移到另一个状态。\nInitial State : 系统的初始状态。\n例题（字符串匹配） 在了解有限状态机的两种类型前，我们先来看一道例题（选自BUAA_CO_P0）\n使用Logisim搭建一个有限状态机检测串行输入字符串中的能匹配正则表达式b{1,2}[ac]{2}的子串并输出。即我们要得到这样一个字符串：开头有一个或两个b，接着要出现两次a/c。\n**注意：**每当匹配到一个子串时，需要输出一次1。例如对字符串bacbacac,模块应当在第1个c输入和第2个c输入时输出1,而在其他时刻保持输出为0。\nMoore Machine 我们先通过Moore状态机来实现题目要求。Moore状态机是有限状态机的一种，其输出仅依赖于当前状态。即只要系统处于某个特定状态，无论当前输入是什么，都会有对应的输出。\n首先我们先画出状态转移图\n根据上图我们可以轻松地在logisim中搭出相应的电路\n利用真值表构建状态转移模块 Mealy Machine 再利用Mealy状态机实现题目要求。Mealy状态机是有限状态机的另外一种，其输出结果不仅和当前状态有关，还和当前输出有关。\n我们仍然是先画出状态转移图\n在logisim中搭建相应电路\n利用真值表构建状态转移模块 由于Mealy状态机的输出Z由状态和输出共同决定，所以可以在构建真值表时直接根据状态和输入给出Z的值。\nMoore \u0026amp; Mealy 下面我们通过波形图的方式分析两种有限状态机的差别。\n上升沿输入一个字符，且输入在一个周期内保持不变 Moore状态机在读入字符c后状态变为11，经过判断符合置位条件，输入变为1，非常符合我们的直觉。\nMealy状态机则在读入字符a后输入就变为1，因为读入a之后状态变为10，此时输入仍为a，状态机识别到字符序列baa，符合置位条件，输入变为1，而在读入c之后状态变为00，不再符合置位条件。\n下降沿输入一个字符，且输入在一个周期内保持不变\n虽然是下降沿读入一个字符，但是状态机的状态在上升沿时才会更新，所以对于Moore状态机，其实就等于上一种情况滞后一个周期。\n对于Mealy状态机，在状态更新为10后，输入仍为a，检测序列为baa，符合置位条件，在之后的下降沿输入变为c，此时检测序列为bac，仍符合置位条件。\n异步输入\n在接收到字符a后的一个周期内任意时刻输入c，Mealy状态机的输出都会立刻发生变化，而Moore状态机则需要等到下一个时钟上沿到来输出才会变化。\n总结 对于本题来说，Moore状态机和Mealy状态机实现的功能有所差异。\n**Moore状态机同步输出，Mealy状态机异步输出。**Mealy对输入的反应更快。\n实现相同功能，Mealy所需要的状态数比Moore型少，Moore需要状态稳定才能输出。（对于异步输入来说，因为同步输入时结果并不相同）\n并非所有时许电路都可以用Mealy状态机实现，一些时序逻辑电路只能通过Moore状态机实现。\n","date":"2024-10-05T16:58:00Z","image":"https://lhy0424.top/p/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/Automata_theory.svg_hu_4eddc70e3799b806.png","permalink":"https://lhy0424.top/p/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/","title":"Moore与Mealy状态机辨析"}]